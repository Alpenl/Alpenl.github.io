import{_ as s,D as a,B as e,ah as o}from"./chunks/framework.kYnPRA0Y.js";const k=JSON.parse('{"title":"认识 Cargo","description":"","frontmatter":{},"headers":[],"relativePath":"notes/Rust基础学习/01认识Cargo.md","filePath":"notes/Rust基础学习/01认识Cargo.md","lastUpdated":1738325247000}'),n={name:"notes/Rust基础学习/01认识Cargo.md"},t=o(`<h1 id="认识-cargo" tabindex="-1">认识 Cargo <a class="header-anchor" href="#认识-cargo" aria-label="Permalink to &quot;认识 Cargo&quot;">​</a></h1><blockquote><p>此笔记记录于<a href="https://course.rs/" target="_blank" rel="noreferrer">Rust Course</a>，大多数为其中的摘要，少数为笔者自己的理解</p></blockquote><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>和 node 中的 npm 类似，<code>cargo</code> 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。同时，与 Rust 语言及其编译器 <code>rustc</code> 紧密结合。</p><h2 id="创建" tabindex="-1">创建 <a class="header-anchor" href="#创建" aria-label="Permalink to &quot;创建&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cargo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> world_hello</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> world_hello</span></span></code></pre></div><p>该项目的结构和配置文件都是由 <code>cargo</code> 生成，意味着<strong>我们的项目被 <code>cargo</code> 所管理</strong></p><p><code>cargo</code> 默认就创建 <code>bin</code> 类型的项目，顺便说一句，Rust 项目主要分为两个类型：<code>bin</code> 和 <code>lib</code>，前者是一个可运行的项目，后者是一个依赖库项目。</p><h2 id="运行" tabindex="-1">运行 <a class="header-anchor" href="#运行" aria-label="Permalink to &quot;运行&quot;">​</a></h2><p>有两种方式可以运行项目：</p><ol><li><code>cargo run</code></li><li>手动编译和运行项目</li></ol><p><code>cargo run</code> == <code>cargo build</code> + <code>./target/debug/world_hello</code></p><p><code>debug</code> 字段表示：我们运行的是 <code>debug</code> 模式，在这种模式下，<strong>代码的编译速度会非常快</strong>，可是福兮祸所伏，<strong>运行速度就慢了</strong>. 原因是，在 <code>debug</code> 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p><p>如果需要发布，则需要添加<code>--release</code>参数，就和前端中<code>dev</code>与<code>build</code>的区别类似。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cargo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --release</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cargo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --release</span></span></code></pre></div><h2 id="cargo-check" tabindex="-1">cargo check <a class="header-anchor" href="#cargo-check" aria-label="Permalink to &quot;cargo check&quot;">​</a></h2><p>作用：当项目大了后，<code>cargo run</code> 和 <code>cargo build</code> 不可避免的会变慢，<code>cargo check</code>可以以更快的方式来验证代码的正确性</p><h2 id="cargo-toml-和-cargo-lock" tabindex="-1">Cargo.toml 和 Cargo.lock <a class="header-anchor" href="#cargo-toml-和-cargo-lock" aria-label="Permalink to &quot;Cargo.toml 和 Cargo.lock&quot;">​</a></h2><blockquote><p>类比 npm 中 package.json 与 lock</p></blockquote><ul><li><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</li><li><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong>，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</li></ul><blockquote><p>什么情况下该把 <code>Cargo.lock</code> 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中。</p></blockquote><p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p><ul><li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li><li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li><li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[dependencies]</span></span>
<span class="line"><span>rand = &quot;0.3&quot;</span></span>
<span class="line"><span>hammer = { version = &quot;0.5.0&quot;}</span></span>
<span class="line"><span>color = { git = &quot;https://github.com/bjz/color-rs&quot; }</span></span>
<span class="line"><span>geometry = { path = &quot;crates/geometry&quot; }</span></span></code></pre></div><h2 id="下载依赖很慢" tabindex="-1">下载依赖很慢 <a class="header-anchor" href="#下载依赖很慢" aria-label="Permalink to &quot;下载依赖很慢&quot;">​</a></h2><h3 id="开启命令行或者全局翻墙" tabindex="-1">开启命令行或者全局翻墙 <a class="header-anchor" href="#开启命令行或者全局翻墙" aria-label="Permalink to &quot;开启命令行或者全局翻墙&quot;">​</a></h3><p>经常有同学反馈，我明明开启翻墙了，但是下载依然还是很慢，无论是命令行中下载还是 VSCode 的 rust-analyzer 插件自动拉取。</p><p>事实上，翻墙工具默认开启的仅仅是浏览器的翻墙代理，对于命令行或者软件中的访问，并不会代理流量，因此这些访问还是通过正常网络进行的，自然会失败。</p><p>因此，大家需要做的是在你使用的翻墙工具中 <code>复制终端代理命令</code> 或者开启全局翻墙。由于每个翻墙软件的使用方式不同，因此具体的还是需要自己研究下。以我使用的 <code>ClashX</code> 为例，点击 <code>复制终端代理命令</code> 后，会自动复制一些 <code>export</code> 文本，将这些文本复制到命令行终端中，执行一下，就可以自动完成代理了。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> https_proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http://127.0.0.1:7890 http_proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http://127.0.0.1:7890 all_proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socks5://127.0.0.1:7891</span></span></code></pre></div><h3 id="使用国内镜像" tabindex="-1">使用国内镜像 <a class="header-anchor" href="#使用国内镜像" aria-label="Permalink to &quot;使用国内镜像&quot;">​</a></h3><p>为了使用 <code>crates.io</code> 之外的注册服务，我们需要对 <code>$HOME/.cargo/config.toml</code> ($CARGO_HOME 下) 文件进行配置，添加新的服务提供商，有两种方式可以实现：增加新的镜像地址和覆盖默认的镜像地址。</p><p><strong>首先是在 <code>crates.io</code> 之外添加新的注册服务</strong>，在 <code>$HOME/.cargo/config.toml</code> （如果文件不存在则手动创建一个）中添加以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[registries]</span></span>
<span class="line"><span>ustc = { index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot; }</span></span></code></pre></div><p>这种方式只会新增一个新的镜像地址，因此在引入依赖的时候，需要指定该地址，例如在项目中引入 <code>time</code> 包，你需要在 <code>Cargo.toml</code> 中使用以下方式引入:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[dependencies]</span></span>
<span class="line"><span>time = { registry = &quot;ustc&quot; }</span></span></code></pre></div><p><strong>在重新配置后，初次构建可能要较久的时间</strong>，因为要下载更新 <code>ustc</code> 注册服务的索引文件，由于文件比较大，需要等待较长的时间。</p><p>此处有两点需要注意：</p><ol><li>cargo 1.68 版本开始支持稀疏索引，不再需要完整克隆 crates.io-index 仓库，可以加快获取包的速度，如：</li></ol><p><code>[source.ustc] registry = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;</code></p><ol start="2"><li>cargo search 无法使用镜像</li></ol><h4 id="字节跳动" tabindex="-1"><a href="https://course.rs/first-try/slowly-downloading.html#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8" target="_blank" rel="noreferrer">字节跳动</a> <a class="header-anchor" href="#字节跳动" aria-label="Permalink to &quot;[字节跳动](https://course.rs/first-try/slowly-downloading.html#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8)&quot;">​</a></h4><p>最大的优点就是不限速，当然，你的网速如果能跑到 1000Gbps，我们也可以认为它无情的限制了你，咳咳。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[source.crates-io]</span></span>
<span class="line"><span>replace-with = &#39;rsproxy&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[source.rsproxy]</span></span>
<span class="line"><span>registry = &quot;https://rsproxy.cn/crates.io-index&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 稀疏索引，要求 cargo &gt;= 1.68</span></span>
<span class="line"><span>[source.rsproxy-sparse]</span></span>
<span class="line"><span>registry = &quot;sparse+https://rsproxy.cn/index/&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[registries.rsproxy]</span></span>
<span class="line"><span>index = &quot;https://rsproxy.cn/crates.io-index&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[net]</span></span>
<span class="line"><span>git-fetch-with-cli = true</span></span></code></pre></div><h3 id="覆盖默认的镜像地址" tabindex="-1">覆盖默认的镜像地址 <a class="header-anchor" href="#覆盖默认的镜像地址" aria-label="Permalink to &quot;覆盖默认的镜像地址&quot;">​</a></h3><p>事实上，我们更推荐第二种方式，因为第一种方式在项目大了后，实在是很麻烦，全部修改后，万一以后不用这个镜像了，你又要全部修改成其它的。</p><p>而第二种方式，则不需要修改 <code>Cargo.toml</code> 文件，<strong>因为它是直接使用新注册服务来替代默认的 <code>crates.io</code></strong>。</p><p>在 <code>$HOME/.cargo/config.toml</code> 添加以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[source.crates-io]</span></span>
<span class="line"><span>replace-with = &#39;ustc&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[source.ustc]</span></span>
<span class="line"><span>registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span></code></pre></div><p>首先，创建一个新的镜像源 <code>[source.ustc]</code>，然后将默认的 <code>crates-io</code> 替换成新的镜像源: <code>replace-with = &#39;ustc&#39;</code>。</p>`,50),i=[t];function c(p,l,r,d,h,g){return e(),a("div",null,i)}const b=s(n,[["render",c]]);export{k as __pageData,b as default};
