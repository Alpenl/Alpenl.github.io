import{_ as a,D as e,B as t,ah as o}from"./chunks/framework.kYnPRA0Y.js";const b=JSON.parse('{"title":"其他部分","description":"","frontmatter":{},"headers":[],"relativePath":"notes/微前端设计与实现/05其他.md","filePath":"notes/微前端设计与实现/05其他.md","lastUpdated":1738344267000}'),i={name:"notes/微前端设计与实现/05其他.md"},r=o('<h1 id="其他部分" tabindex="-1">其他部分 <a class="header-anchor" href="#其他部分" aria-label="Permalink to &quot;其他部分&quot;">​</a></h1><h2 id="第-5-章-微前端技术实现" tabindex="-1">第 5 章　微前端技术实现 <a class="header-anchor" href="#第-5-章-微前端技术实现" aria-label="Permalink to &quot;第 5 章　微前端技术实现&quot;">​</a></h2><h3 id="横向拆分与纵向拆分的区别" tabindex="-1">横向拆分与纵向拆分的区别 <a class="header-anchor" href="#横向拆分与纵向拆分的区别" aria-label="Permalink to &quot;横向拆分与纵向拆分的区别&quot;">​</a></h3><p>都是根据业务领域进行拆分，只是纵向拆分更多是一个页面就是一个微前端，同时只激活一个微前端，而横向拆分稍微复杂，一个页面里面可能包含多个微前端。</p><p>纵向拆分更适合身份认证和目录这两个业务需求，而横向拆分更适合账户管理子域，满足其服务多个子域的业务需求。</p><h3 id="module-federation-入门" tabindex="-1">Module Federation 入门 <a class="header-anchor" href="#module-federation-入门" aria-label="Permalink to &quot;Module Federation 入门&quot;">​</a></h3><ul><li>host：在运行时加载共享库、微前端或组件的容器。</li><li>remote：我们要在本地加载的 JavaScript 代码包。</li></ul><p>在本书的案例中，host 代表了 App shell，remote 代表其中的一个微前端。</p><p>host 负责在运行时加载一些 JavaScript 捆绑包；remote 代表任何类型的 JavaScript 捆绑包，比如共享库、微前端，甚至是组件</p><p>共享可以是双向的，remote 与 host 可以共享部分或整个捆绑包。但是，使用双向共享会很快让架构变得复杂。最好的方法是单向共享，这样 host 就不会与 remote 共享任何内容，调试会更加容易，同时可以降低子域向 host 泄露的风险，从而避免 host 和 remote 之间的设计耦合。</p><p>因为 Module Federation 是一个 webpack 插件，所以我们可以使用 webpack 的其他功能进行代码优化</p><h2 id="第-6-章-构建和部署微前端" tabindex="-1">第 6 章　构建和部署微前端 <a class="header-anchor" href="#第-6-章-构建和部署微前端" aria-label="Permalink to &quot;第 6 章　构建和部署微前端&quot;">​</a></h2><h3 id="自动化策略的重要性。" tabindex="-1">自动化策略的重要性。 <a class="header-anchor" href="#自动化策略的重要性。" aria-label="Permalink to &quot;自动化策略的重要性。&quot;">​</a></h3><p>微服务增强了业务架构的灵活性和可伸缩性，使业务能够根据基础架构的流量对 API 进行横向扩展，并且不同于单体架构的单一方案，我们可以根据业务的特点选择不同的实现方式。尽管微服务具有上述的强大功能，但这些实现方式需要大量的重复性操作进行构建和部署，从而增加了基础架构管理的复杂度。因此，任何使用微服务的公司都必须在持续集成（continuous integration，CI）或持续部署（continuous deployment，CD）上投入大量的时间和精力。</p><h3 id="测试策略" tabindex="-1">测试策略 <a class="header-anchor" href="#测试策略" aria-label="Permalink to &quot;测试策略&quot;">​</a></h3><p>但是，当测试用例不得不覆盖别的团队业务时，就会有一定的难度</p><p>横向拆分也有一定的问题，它会引发谁来负责对最终效果进行端到端测试的问题</p><h3 id="灰度发布" tabindex="-1">灰度发布 <a class="header-anchor" href="#灰度发布" aria-label="Permalink to &quot;灰度发布&quot;">​</a></h3><p>在灰度发布中，我们不会在测试通过后将所有流量切换到新版本。相反，我们会逐步将流量引到新版本。我们监控新版本的实时指标，当错误率增加或用户访问量降低时，我们会相应地减少流量</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230903182909.png" alt=""></p><p>微前端的数量过多可能会导致瓶颈，因为要匹配所有内容就需要在客户端加载一个很大的配置表。所以，我们为客户端提供了一个针对特定 URL 所需的配置系统，提供的配置包括发布和测试不同的组合逻辑、使用 API 或负载均衡控制流量以便在新老版本之间切换。</p><h3 id="绞杀者模式" tabindex="-1">绞杀者模式 <a class="header-anchor" href="#绞杀者模式" aria-label="Permalink to &quot;绞杀者模式&quot;">​</a></h3><p>绞杀者模式来源于这样一种想法：通过发布应用的部分功能为企业和用户不断提供增量价值，而不是等待全量功能准备就绪再做发布。</p><p>当用户请求微前端实现的页面时，路由切换到微前端的方式提供服务。当应用的某个区域尚未准备好时，路由会将用户重定向到之前的平台。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230903183019.png" alt=""></p><p>在绞杀者模式中，微前端与原有应用并存，这样不用等到整个应用开发完成，我们就可以为用户和公司创造即时价值</p><h3 id="可观察性" tabindex="-1">可观察性 <a class="header-anchor" href="#可观察性" aria-label="Permalink to &quot;可观察性&quot;">​</a></h3><p>过去几年，前端生态中出现了许多监控工具，比如 Sentry、New Relic 或 LogRocket，这些工具允许我们在遇到问题时记录用户行为。</p><h2 id="第-7-章-案例分析-微前端自动化流水线" tabindex="-1">第 7 章　案例分析：微前端自动化流水线 <a class="header-anchor" href="#第-7-章-案例分析-微前端自动化流水线" aria-label="Permalink to &quot;第 7 章　案例分析：微前端自动化流水线&quot;">​</a></h2><p>项目中的自动化策略由 6 个关键部分组成：</p><ul><li>版本控制；</li><li>流水线初始化；</li><li>代码质量审查；</li><li>构建；</li><li>构建后检查；</li><li>部署。</li></ul><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230903183139.png" alt=""></p><h2 id="第-8-章-微前端的后端模式" tabindex="-1">第 8 章　微前端的后端模式 <a class="header-anchor" href="#第-8-章-微前端的后端模式" aria-label="Permalink to &quot;第 8 章　微前端的后端模式&quot;">​</a></h2><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230903183206.png" alt=""> 服务字典：</p><p>服务字典是一个供客户端调用的服务列表，它主要是在单体应用或模块化单体应用中开发 API 层时使用。服务字典避免了在持续集成过程中创建并注入共享库、环境变量或配置，也避免了在前端代码库中硬编码所有服务接入点的地址。</p>',35),l=[r];function s(h,n,p,d,c,u){return t(),e("div",null,l)}const _=a(i,[["render",s]]);export{b as __pageData,_ as default};
