import{_ as l,D as a,B as i,ah as e}from"./chunks/framework.kYnPRA0Y.js";const m=JSON.parse('{"title":"数据库设计","description":"","frontmatter":{},"headers":[],"relativePath":"notes/数据库01/07数据库设计.md","filePath":"notes/数据库01/07数据库设计.md","lastUpdated":1738325247000}'),t={name:"notes/数据库01/07数据库设计.md"},o=e('<h1 id="数据库设计" tabindex="-1">数据库设计 <a class="header-anchor" href="#数据库设计" aria-label="Permalink to &quot;数据库设计&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><ul><li>直观设计法</li><li>规范设计法 <ul><li>新奥尔良方法</li><li>基于 ER 模型的方法</li><li>基于 3NF 的方法</li></ul></li><li>计算机辅助设计方法</li></ul><h3 id="步骤" tabindex="-1">步骤 <a class="header-anchor" href="#步骤" aria-label="Permalink to &quot;步骤&quot;">​</a></h3><ol><li>需求设计阶段</li><li>概念结构设计阶段</li><li>逻辑结构设计阶段</li><li>物理结构设计阶段</li><li>数据库的实施阶段</li><li>数据库运行和维护阶段</li></ol><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>数据库设计是涉及多学科的综合技术</li><li>数据库涉及是硬件、软件和干件的结合</li><li>数据库涉及具有反复性、试探性、应分步进行</li><li>数据库涉及需要将结构设计和行为设计密切结合</li></ul><h2 id="需求分析" tabindex="-1">需求分析 <a class="header-anchor" href="#需求分析" aria-label="Permalink to &quot;需求分析&quot;">​</a></h2><h3 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-label="Permalink to &quot;任务&quot;">​</a></h3><ul><li>需求分析的任务是通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。</li><li>调查的重点是“数据”和“业务处理”</li><li>确定业务规则：业务处理数据以及产生数据的方法和步骤（能不能实现这项功能，查到这项数据）</li></ul><h3 id="需求信息的收集" tabindex="-1">需求信息的收集 <a class="header-anchor" href="#需求信息的收集" aria-label="Permalink to &quot;需求信息的收集&quot;">​</a></h3><p>步骤：</p><ul><li>业务知识的研究</li><li>指定调研计划</li><li>选用调研方法进行调研</li></ul><p>信息的来源：</p><ul><li>客户</li><li>最终用户</li><li>管理人员</li></ul><h3 id="内容" tabindex="-1">内容 <a class="header-anchor" href="#内容" aria-label="Permalink to &quot;内容&quot;">​</a></h3><ul><li>调查组织机构情况</li><li>调查各部分对新系统的各种要求</li><li>协助用户明确对新系统的各种要求</li><li>确定新系统的边界</li></ul><h3 id="业务及数据分析" tabindex="-1">业务及数据分析 <a class="header-anchor" href="#业务及数据分析" aria-label="Permalink to &quot;业务及数据分析&quot;">​</a></h3><ul><li><strong>业务</strong>是企业、组织为实现自身目标、职能的一系列有序的活动过程</li><li><strong>业务分析</strong>就是对上述各种流动及其交织过程的详细分析过程</li><li><strong>数据分析</strong>就是把数据在组织内部的业务流动情况，以数据流动的方式抽象出来，从数据流动过程来分析业务系统的数据处理模式</li></ul><p>相关内容：</p><ul><li>确定业务</li><li>业务流程分析</li><li>业务规则分析</li><li>数据流程分析</li></ul><h3 id="数据字典" tabindex="-1">数据字典 <a class="header-anchor" href="#数据字典" aria-label="Permalink to &quot;数据字典&quot;">​</a></h3><ul><li>数据项： 不可再分的数据单位</li><li>数据结构：反映数据间的组合关系</li><li>数据流：是数据结构在系统内的传输途径，表示某一处理过程的输入或输出</li><li>数据存储：数据结构停留和保存的地方，数据流的来源与去向之一</li><li>处理过程：描述业务处理的处理逻辑和输入输出</li></ul><h2 id="概念模型" tabindex="-1">概念模型 <a class="header-anchor" href="#概念模型" aria-label="Permalink to &quot;概念模型&quot;">​</a></h2><h3 id="联系" tabindex="-1">联系 <a class="header-anchor" href="#联系" aria-label="Permalink to &quot;联系&quot;">​</a></h3><p>两个或两个以上实体集之间的联系、实体之间的联系都存在下面三种联系</p><p><strong>一对一(1:1)</strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116111502.png" alt=""></p><p><strong>一对多(1:n)</strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116111550.png" alt=""></p><p><strong>多对多(m:n)</strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116111626.png" alt=""></p><h3 id="表示方法" tabindex="-1">表示方法 <a class="header-anchor" href="#表示方法" aria-label="Permalink to &quot;表示方法&quot;">​</a></h3><ul><li>实体型：矩形</li><li>椭圆：属性</li><li>联系：菱形</li></ul><h3 id="方法步骤" tabindex="-1">方法步骤 <a class="header-anchor" href="#方法步骤" aria-label="Permalink to &quot;方法步骤&quot;">​</a></h3><ul><li>自项向下：从全局出发，先设计出全局概念模型框架，然后逐步细化</li><li>自底向上：从局部应用出发，先设计出各局部应用的概念模型，然后再对局部应用的概念模型进行综合，形成全局概念模型</li><li>逐步扩张：首先定义最基本、最核心的概念模型，逐步扩大至其相关的概念模型，以滚雪球的方式进行概念模型的扩张，最终形成全局的概念模型。</li><li>混合策略：【略】</li></ul><h3 id="数据抽象" tabindex="-1">数据抽象 <a class="header-anchor" href="#数据抽象" aria-label="Permalink to &quot;数据抽象&quot;">​</a></h3><h4 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h4><ul><li>分类定义某一概念作为现实世界中一组对象的类型，这些对象具有某些共同的特性和行为</li><li>它抽象了对象值和型之间的<code>is member of</code>的语义</li></ul><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116115545.png" alt=""></p><h4 id="聚集" tabindex="-1">聚集 <a class="header-anchor" href="#聚集" aria-label="Permalink to &quot;聚集&quot;">​</a></h4><ul><li>聚集是将若干对象和它们之间的联系组合成一个新的对象</li><li>它抽象了对象内部类型和成分之间<code>is part of</code>的语义</li></ul><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116115742.png" alt=""></p><h4 id="概括" tabindex="-1">概括 <a class="header-anchor" href="#概括" aria-label="Permalink to &quot;概括&quot;">​</a></h4><ul><li>概括将一组具有共同特性的对象合并成更高一层意义上的对象</li><li>它抽象了类型之间的<code>is subset of</code>的语义</li></ul><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116115930.png" alt=""></p><h3 id="实体与属性" tabindex="-1">实体与属性 <a class="header-anchor" href="#实体与属性" aria-label="Permalink to &quot;实体与属性&quot;">​</a></h3><ul><li>现实世界中能作为属性对待的，尽量作为属性对待</li><li>作为属性，不能再具有需要描述的性质即属性不能是另一些属性的聚集</li><li>属性不能与其他实体具有联系，即 ER 图中的联系是实体之间的联系</li></ul><h3 id="合并分-er-图" tabindex="-1">合并分 ER 图 <a class="header-anchor" href="#合并分-er-图" aria-label="Permalink to &quot;合并分 ER 图&quot;">​</a></h3><blockquote><p>将一些设计好的小 ER 图（局部）合并为整张 ER 图（视图集成）</p></blockquote><h4 id="属性冲突" tabindex="-1">属性冲突 <a class="header-anchor" href="#属性冲突" aria-label="Permalink to &quot;属性冲突&quot;">​</a></h4><ul><li>属性域冲突 <ul><li>类型</li><li>取值范围</li><li>取值集合</li></ul></li><li>属性取值单位冲突</li></ul><h4 id="命名冲突" tabindex="-1">命名冲突 <a class="header-anchor" href="#命名冲突" aria-label="Permalink to &quot;命名冲突&quot;">​</a></h4><ul><li>同名异义</li><li>异名同义</li></ul><h4 id="结构冲突" tabindex="-1">结构冲突 <a class="header-anchor" href="#结构冲突" aria-label="Permalink to &quot;结构冲突&quot;">​</a></h4><ul><li>同一对象在不同应用中具有不同抽象（属性变换为实体或实体变换为属性）</li><li>同一对象在不同分 ER 图中属性组成不同，包括属性个数、次序（属性取并再适当调整属性的次序）</li><li>实体之间的联系在不同分 ER 图中呈现不同的类型（实际调整）</li></ul><h3 id="修改和重构" tabindex="-1">修改和重构 <a class="header-anchor" href="#修改和重构" aria-label="Permalink to &quot;修改和重构&quot;">​</a></h3><p>消除不必要的冗余：</p><ul><li>冗余的数据是指可由基本数据导出的数据</li><li>冗余的联系是指可有其他联系导出的联系</li><li>消除冗余的方法主要有分析法和规范化理论方法</li></ul><p>【例】将校园超市的库存管理和销售管理分 E-R 图集成生成全局基本 E-R 图。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116121321.png" alt=""></p><p>全局 ER 图：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116121359.png" alt=""></p><h2 id="概念模型向关系模型转换" tabindex="-1">概念模型向关系模型转换 <a class="header-anchor" href="#概念模型向关系模型转换" aria-label="Permalink to &quot;概念模型向关系模型转换&quot;">​</a></h2><h3 id="实体的转换规则" tabindex="-1">实体的转换规则 <a class="header-anchor" href="#实体的转换规则" aria-label="Permalink to &quot;实体的转换规则&quot;">​</a></h3><ul><li>一个实体转换为一个关系模式</li><li>实体的属性就是关系的属性</li><li>实体的码就是关系的码</li></ul><p>【例】将校园超市概念模型中的实体转换为关系模式。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116221755.png" alt=""></p><p>转换为：</p><ul><li>商品（商品编码，商品名，条形码，进价，售价，单位，备注）</li><li>商品类型（类型编码，类型名称）</li><li>学生（学号，姓名，性别，出生年月，学院，专业，微信号）</li><li>仓库（仓库号，仓库电话，仓库面积）</li><li>仓库管理员（员工号，员工名，员工年龄）</li></ul><h3 id="联系的转换规则" tabindex="-1">联系的转换规则 <a class="header-anchor" href="#联系的转换规则" aria-label="Permalink to &quot;联系的转换规则&quot;">​</a></h3><h4 id="一对一转换" tabindex="-1">一对一转换 <a class="header-anchor" href="#一对一转换" aria-label="Permalink to &quot;一对一转换&quot;">​</a></h4><ul><li>一个 1:1 联系可以转换成一个独立的关系模式，也可以与任意一端对应的关系模式合并。</li><li>如果转换成一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。</li><li>如果与某一段实体的关系合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。</li></ul><p>【例】现有员工实体有员工号，员工姓名，员工性别，工资等属性，其中员工号是员工实体的码；工资账户实体有开户行，账号，银行地址，电话等属性，其中账号是工资账户的码；员工实体与工资账户实体之间是一对一联系。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116222925.png" alt=""></p><p>（1）将该 1:1 联系转换成独立的关系模式如下：拥有（员工号，账号）或者拥有（员工号，账号）</p><p>（2）将该 1:1 联系合并到员工端结果如下：</p><ul><li>员工（员工号，员工姓名，员工性别，工资，账号）</li><li>工资账户（开户行，账号，电话，银行地址）</li></ul><p>（3）将该 1:1 联系合并到工资账户端结果如下：</p><ul><li>员工（员工号，员工姓名，员工性别，工资）</li><li>工资账户（开户行，账号，电话，银行地址，员工号）</li></ul><h4 id="一对多转换" tabindex="-1">一对多转换 <a class="header-anchor" href="#一对多转换" aria-label="Permalink to &quot;一对多转换&quot;">​</a></h4><blockquote><p>只能合并到 n 端的那张表，或者新建一张关系表</p></blockquote><ul><li>一个 1:n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并。</li><li>如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为 n 端实体的码。</li><li>如果合并到 n 端，则在 n 端关系中加入 1 端实体的码和联系本身的属性，关系的码不变。</li></ul><p>【例】现有商品实体有商品编码，商品名，条形码，进价，售价，单位，备注等属性，其中商品编码是商品实体的码；仓库实体有仓库号，仓库电话，仓库面积等属性，其中仓库号是仓库实体的码；仓库实体与商品实体之间是一对多联系。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116223159.png" alt=""></p><p>（1）将该 1:1n 联系转换成独立的关系模式如下：存放（商品编码，仓库号，数量）</p><p>（2）将该 1:n 联系合并到 n 端结果如下：</p><ul><li>商品（商品编码，商品名，条形码，进价，售价，单位，</li><li>备注，数量，仓库号）</li><li>仓库（仓库号，仓库电话，仓库面积）</li></ul><h4 id="多对多转换" tabindex="-1">多对多转换 <a class="header-anchor" href="#多对多转换" aria-label="Permalink to &quot;多对多转换&quot;">​</a></h4><blockquote><p>不能合并，只能新建一张关系表</p></blockquote><p>一个 m:n 联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转 换为关系的属性，各实体的码共同组成该关系模式的码。</p><p>【例】现有商品实体有商品编码，商品名，条形码，进价，售价，单位，备注等属性，其中商品编码是商品实体的码；学生实体有学号，姓名，出生年份，性别，学院，专业，微信号等属性，其中学号是学生实体的码；商品实体与学生实体之间是多对多联系。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116223448.png" alt=""></p><h4 id="多元联系转换" tabindex="-1">多元联系转换 <a class="header-anchor" href="#多元联系转换" aria-label="Permalink to &quot;多元联系转换&quot;">​</a></h4><ul><li>三个或三个以上的实体间的一个多元联系可以转换为一个关系模式</li><li>与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性；</li><li>关系的码为诸实体码的组合。</li></ul><p>【例】一个厂家可以生产多种零件组装成多种产品，每个产品可以使用多个厂家生产的零件，每种零件可以有不同的厂家生产，则在厂家、零件和产品之间是多对多的联系。</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116223654.png" alt=""></p><p>厂家，产品，零件三者之间的多对多联系转换为一个独立的关系模式，结果如下：</p><p>生产（厂家号，产品号，零件号）</p><h4 id="相同码的转换" tabindex="-1">相同码的转换 <a class="header-anchor" href="#相同码的转换" aria-label="Permalink to &quot;相同码的转换&quot;">​</a></h4><ul><li>具有相同码的关系模式可以合并。</li><li>目的是减少系统中的关系个数。</li><li>合并方法是将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义性，并适当调整属性的次序。</li></ul><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020230116223818.png" alt=""></p>',103),r=[o];function s(h,n,u,d,c,p){return i(),a("div",null,r)}const g=l(t,[["render",s]]);export{m as __pageData,g as default};
