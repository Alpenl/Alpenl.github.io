import{_ as i,c as a,as as n,o as t}from"./chunks/framework.CsiIftoR.js";const c=JSON.parse('{"title":"python 数据模型","description":"","frontmatter":{},"headers":[],"relativePath":"notes/Python基础/01python数据模型.md","filePath":"notes/Python基础/01python数据模型.md","lastUpdated":1738327344000}'),e={name:"notes/Python基础/01python数据模型.md"};function h(d,s,k,l,p,r){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="python-数据模型" tabindex="-1">python 数据模型 <a class="header-anchor" href="#python-数据模型" aria-label="Permalink to &quot;python 数据模型&quot;">​</a></h1><blockquote><p>此笔记记录于《流畅的 python》，大部分为其中的摘要，少部分为笔者自己的理解；笔记为 jupyter 转的 markdown，原始版 jupyter 笔记在<a href="https://github.com/Justin3go/fluent-python-note" target="_blank" rel="noreferrer">这个仓库</a></p></blockquote><h2 id="起步" tabindex="-1">起步 <a class="header-anchor" href="#起步" aria-label="Permalink to &quot;起步&quot;">​</a></h2><p>python 的一些设计理念</p><ul><li>Guido 知道如何在理论上做出一定妥协，设计出来的语言让使用者觉得如沐春风，这真是不可多得。</li><li>Python 最好的品质之一是一致性。当你使用 Python 工作一会儿后，就会开始理解 Python 语言，并能正确猜测出对你来说全新的语言特征。</li></ul><p>python 中的魔术方法：</p><p>调用过程：Python 解释器碰到特殊的句法时，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾（例如<code>__getitem__</code>）。比如<code>obj[key]</code>的背后就是<code>__getitem__</code>方法，为了能求得<code>my_collection[key]</code>的值，解释器实际上会调用<code>my_collection.__getitem__(key)</code>。</p><p>包含以下几个类别：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即 with 块）</li></ul><h2 id="纸牌类" tabindex="-1">纸牌类 <a class="header-anchor" href="#纸牌类" aria-label="Permalink to &quot;纸牌类&quot;">​</a></h2><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Card </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.namedtuple(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Card&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;rank&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;suit&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FrenchDeck</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ranks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;JQKA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    suits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;spades diamonds clubs hearts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.split()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._cards </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Card(rank, suit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> suit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.suits</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                                        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rank </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ranks]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __len__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._cards)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __getitem__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, position):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._cards[position]</span></span></code></pre></div><p>上述代码的注意事项：</p><p>利用 namedtuple（用以构建只有少数属性但是没有方法的对象），我们可以很轻松地得到一个纸牌对象，这里代表一张纸牌，它由一个 rank（排名）和一个 suit（花色）两个属性构成</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><pre><code>[1, 2, 3, 2, 3, 4]
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deck </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FrenchDeck()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deck)</span></span></code></pre></div><pre><code>52
</code></pre><p>它跟任何标准 Python 集合类型一样，可以用<code>len()</code>函数来查看一叠牌有多少张，因为内部实现<code>__len__</code>方法，其实就是调用的这个方法。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;spades diamonds clubs hearts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.split()</span></span></code></pre></div><pre><code>[&#39;spades&#39;, &#39;diamonds&#39;, &#39;clubs&#39;, &#39;hearts&#39;]
</code></pre><p>python 也已经内置了从一个序列中随机选出一个元素的函数 random.choice</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> random </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> choice</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deck </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FrenchDeck()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">choice(deck)</span></span></code></pre></div><pre><code>Card(rank=&#39;10&#39;, suit=&#39;diamonds&#39;)
</code></pre><p>因为__getitem__方法把[]操作交给了 self._cards 列表，所以我们的 deck 类自动支持切片（slicing）操作。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deck[:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><pre><code>[Card(rank=&#39;2&#39;, suit=&#39;spades&#39;),
 Card(rank=&#39;3&#39;, suit=&#39;spades&#39;),
 Card(rank=&#39;4&#39;, suit=&#39;spades&#39;)]
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deck[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><pre><code>[Card(rank=&#39;A&#39;, suit=&#39;spades&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;diamonds&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;clubs&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;hearts&#39;)]
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> card </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reversed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deck):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(card)</span></span></code></pre></div><pre><code>Card(rank=&#39;A&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;K&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;J&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;10&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;9&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;8&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;7&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;6&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;5&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;4&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;3&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;2&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;A&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;K&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;J&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;10&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;9&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;8&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;7&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;6&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;5&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;4&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;3&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;2&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;A&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;K&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;J&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;10&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;9&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;8&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;7&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;6&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;5&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;4&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;3&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;2&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;A&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;K&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;J&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;10&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;9&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;8&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;7&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;6&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;5&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;4&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;3&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;2&#39;, suit=&#39;spades&#39;)
</code></pre><p>迭代通常是隐式的，譬如说一个集合类型没有实现__contains__方法，那么 in 运算符就会按顺序做一次迭代搜索。于是，in 运算符可以用在我们的 FrenchDeck 类上，因为它是可迭代的</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Card(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Q&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hearts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deck</span></span></code></pre></div><pre><code>True
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 自定义排序函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">suit_values </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spades</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hearts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">diamonds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">clubs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spades_high</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(card):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rank_value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FrenchDeck.ranks.index(card.rank)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rank_value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(suit_values)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">suit_values[card.suit]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> card </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deck, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spades_high):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(card)</span></span></code></pre></div><pre><code>Card(rank=&#39;2&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;2&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;2&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;2&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;3&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;3&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;3&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;3&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;4&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;4&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;4&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;4&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;5&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;5&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;5&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;5&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;6&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;6&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;6&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;6&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;7&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;7&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;7&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;7&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;8&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;8&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;8&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;8&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;9&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;9&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;9&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;9&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;10&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;10&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;10&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;10&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;J&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;J&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;J&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;J&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;Q&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;K&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;K&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;K&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;K&#39;, suit=&#39;spades&#39;)
Card(rank=&#39;A&#39;, suit=&#39;clubs&#39;)
Card(rank=&#39;A&#39;, suit=&#39;diamonds&#39;)
Card(rank=&#39;A&#39;, suit=&#39;hearts&#39;)
Card(rank=&#39;A&#39;, suit=&#39;spades&#39;)
</code></pre><h2 id="如何使用特殊方法" tabindex="-1">如何使用特殊方法 <a class="header-anchor" href="#如何使用特殊方法" aria-label="Permalink to &quot;如何使用特殊方法&quot;">​</a></h2><ul><li>没有<code>my_object.__len__（　）</code>这种写法，而应该使用<code>len(my_object)</code>，Python 会自己去调用其中由你实现的<code>__len__</code>方法。</li><li>如果是 Python 内置的类型，比如列表（list）、字符串（str）、字节序列（bytearray）等，那么 CPython 会抄个近路，<code>__len__</code>实际上会直接返回 PyVarObject 里的 ob_size 属性。PyVarObject 是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比调用一个方法要快很多。</li><li>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可能是<code>__init__</code>方法，你的代码里可能经常会用到它，目的是在你自己的子类的<code>__init__</code>方法中调用超类的构造器。</li><li>通过内置的函数（例如 len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</li><li>不要自己想当然地随意添加特殊方法，比如__foo__之类的，因为虽然现在这个名字没有被 Python 内部使用，以后就不一定了。</li></ul><p><strong>模拟一个向量类</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> math </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hypot</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __repr__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Vector(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __abs__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hypot(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __bool__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __add__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, other):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">other.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">other.y</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vector(x, y)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __mul__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, scalar):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vector(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scalar, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scalar)</span></span></code></pre></div><p>值得注意的是：</p><ul><li>交互式控制台和调试程序（debugger）用 repr 函数来获取字符串表示形式</li><li><code>__repr__</code>和<code>__str__</code>的区别在于，后者是在 str（　）函数被使用，或是在用 print 函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。</li><li>如果你只想实现这两个特殊方法中的一个，<code>__repr__</code>是更好的选择，因为如果一个对象没有<code>__str__</code>函数，而 Python 又需要调用它的时候，解释器会用<code>__repr__</code>作为替代。</li><li>通过<code>__add__</code>和<code>__mul__</code>，为向量类带来了<code>+</code>和<code>*</code>这两个算术运算符。</li></ul><blockquote><p>这两个方法的返回值都是新创建的向量对象，被操作的两个向量（self 或 other）还是原封不动，代码里只是读取了它们的值而已。中缀运算符的基本原则就是不改变操作对象，而是产出一个新的值。</p></blockquote><ul><li>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。<code>bool(x)</code>的背后是调用 x.<code>__bool__（　）</code>的结果；如果不存在<code>__bool__</code>方法，那么<code>bool(x)</code>会尝试调用<code>x.__len__（　）</code>。若返回 0，则 bool 会返回 False；否则返回 True。</li></ul><p>Python 的内置魔法方法可以按照其功能大致分类如下：</p><table tabindex="0"><thead><tr><th>分类</th><th>魔法方法</th></tr></thead><tbody><tr><td>基本方法</td><td><code>__new__</code>, <code>__init__</code>, <code>__del__</code>, <code>__repr__</code>, <code>__str__</code></td></tr><tr><td>算术运算符</td><td><code>__add__</code>, <code>__sub__</code>, <code>__mul__</code>, <code>__truediv__</code>, <code>__floordiv__</code>, <code>__mod__</code>, <code>__divmod__</code>, <code>__pow__</code>, <code>__lshift__</code>, <code>__rshift__</code>, <code>__and__</code>, <code>__xor__</code>, <code>__or__</code></td></tr><tr><td>反向算术运算符</td><td><code>__radd__</code>, <code>__rsub__</code>, <code>__rmul__</code>, <code>__rtruediv__</code>, <code>__rfloordiv__</code>, <code>__rmod__</code>, <code>__rdivmod__</code>, <code>__rpow__</code>, <code>__rlshift__</code>, <code>__rrshift__</code>, <code>__rand__</code>, <code>__rxor__</code>, <code>__ror__</code></td></tr><tr><td>扩展的赋值运算符</td><td><code>__iadd__</code>, <code>__isub__</code>, <code>__imul__</code>, <code>__itruediv__</code>, <code>__ifloordiv__</code>, <code>__imod__</code>, <code>__ipow__</code>, <code>__ilshift__</code>, <code>__irshift__</code>, <code>__iand__</code>, <code>__ixor__</code>, <code>__ior__</code></td></tr><tr><td>一元运算符</td><td><code>__neg__</code>, <code>__pos__</code>, <code>__abs__</code>, <code>__invert__</code></td></tr><tr><td>属性访问</td><td><code>__getattr__</code>, <code>__getattribute__</code>, <code>__setattr__</code>, <code>__delattr__</code>, <code>__dir__</code></td></tr><tr><td>描述符</td><td><code>__get__</code>, <code>__set__</code>, <code>__delete__</code></td></tr><tr><td>容器类型</td><td><code>__len__</code>, <code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>__contains__</code></td></tr><tr><td>上下文管理</td><td><code>__enter__</code>, <code>__exit__</code></td></tr><tr><td>对象比较</td><td><code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code></td></tr><tr><td>类型转换</td><td><code>__int__</code>, <code>__float__</code>, <code>__bool__</code>, <code>__complex__</code>, <code>__bytes__</code>, <code>__str__</code></td></tr><tr><td>其他</td><td><code>__call__</code>, <code>__hash__</code>, <code>__format__</code>, <code>__sizeof__</code></td></tr></tbody></table><p>以上都是 Python 中常见的一些内置魔法方法，它们用于实现特定的类行为。</p><blockquote><p>当交换两个操作数的位置时，就会调用反向运算符<code>（b * a 而不是 a * b）</code>。增量赋值运算符则是一种把中缀运算符变成赋值运算的捷径<code>（a=a * b 就变成了 a *=b）</code>。</p></blockquote><h2 id="为什么-len-不是普通方法" tabindex="-1">为什么 Len 不是普通方法 <a class="header-anchor" href="#为什么-len-不是普通方法" aria-label="Permalink to &quot;为什么 Len 不是普通方法&quot;">​</a></h2><p>如果 x 是一个内置类型的实例，那么 len(x)的速度会非常快。背后的原因是 CPython 会直接从一个 C 结构体里读取对象的长度，完全不会调用任何方法。获取一个集合中元素的数量是一个很常见的操作，在 str、list、memoryview 等类型上，这个操作必须高效。</p><p>换句话说，len 之所以不是一个普通方法，是为了让 Python 自带的数据结构可以走后门，abs 也是同理。</p><p>也印证了“Python 之禅”中的另外一句话：“不能让特例特殊到开始破坏既定规则。”</p>`,51)]))}const _=i(e,[["render",h]]);export{c as __pageData,_ as default};
