const e=JSON.parse('[{"title":"GitHub Actions 入门指南","url":"/posts/2025/01/GitHub Actions 入门指南","excerpt":"<blockquote>\\n<p>✨文章摘要（AI生成）\\nGitHub Actions 是 GitHub 提供的自动化工具，允许你在代码仓库中直接创建、测试、部署代码的自动化流程。本指南从基础概念到实战示例，手把手教你配置第一个自动化工作流。</p>\\n</blockquote>\\n","date":{"time":1739620800000,"string":"2025/02/15","year":"2025年","monthDay":"02/15"},"tags":["教程","github"]},{"title":"Github配置ssh","url":"/posts/2025/01/Github配置ssh","excerpt":"<blockquote>\\n<p>✨文章摘要\\n介绍了如何在 GitHub 上配置 SSH，包括生成 SSH 密钥对、获取公钥内容、添加公钥到 GitHub 账号以及验证是否设置成功。\\n2025.2.13 新增管理多个 SSH 密钥对的内容。</p>\\n</blockquote>\\n","date":{"time":1738584000000,"string":"2025/02/03","year":"2025年","monthDay":"02/03"},"tags":["教程","ssh","github"]},{"title":"IDEA激活指南","url":"/posts/2025/01/IDEA","excerpt":"<blockquote>\\n<p>✨文章摘要（AI生成）\\n本文是一篇针对Java初学者的IDEA激活教程，主要目的是帮助因无法申请教育免费许可证的用户激活IDEA。教程指出，免费社区版本在学习进阶知识时功能不足，而正式版的教育免费许可证因制裁无法申请，因此提供了以下激活方法。</p>\\n</blockquote>\\n","date":{"time":1738497600000,"string":"2025/02/02","year":"2025年","monthDay":"02/02"},"tags":["教程","IDEA","JAVA"]},{"title":"微信小程序为DOM无缝增加open-type开放能力","url":"/posts/2024/10/21-wechat-mini-program-dom-open-type-capability","excerpt":"<p>在这篇文章中，笔者分享了在开发微信小程序时，如何通过CSS技巧实现<code>button</code>和<code>cell</code>组件的协同工作。由于微信小程序出于安全考虑，无法通过JS模拟点击，因此必须在界面上使用<code>button</code>组件来调用开放能力，比如打开意见反馈页面。为了解决样式统一的问题，笔者将<code>button</code>嵌套在<code>cell</code>中，并通过CSS隐藏<code>button</code>的默认样式。</p>\\n<p>然而，这样的做法导致<code>cell</code>的点击反馈消失，因为事件被<code>button</code>捕获。经过分析，笔者借助<code>pointer-events</code>属性，使得<code>button</code>不捕获鼠标事件，而其内部的<code>cell</code>组件可以正常响应点击。最终，笔者成功实现了既能打开反馈页面，又保留了<code>cell</code>的点击反馈效果的功能。这种方法有效地结合了样式与功能，为开发者提供了实用的解决方案。</p>\\n","date":{"time":1729512000000,"string":"2024/10/21","year":"2024年","monthDay":"10/21"},"tags":["微信小程序","Vue Mini","开放能力","CSS","事件处理"]},{"title":"第三次重构个人博客（基于 Vitepress）","url":"/posts/2024/07/30-third-reconstruction-personal-blog-vitepress","excerpt":"<p>笔者在这篇文章中记录了自己第三次重构个人博客的过程，基于 Vitepress 进行了一系列的改进和优化。自 2022 年初开始使用 Vitepress 搭建博客，随着版本的更新，笔者逐渐感受到原有风格的不适，决定进行重新设计。本次重构的主要内容包括：</p>\\n<ol>\\n<li><strong>首页设计</strong>：采用简单的博客分页列表，利用<code>createContentLoader</code>提取文章摘要等信息。</li>\\n<li><strong>部署与域名管理</strong>：将博客从 Github Pages 迁移至 Cloudflare Pages，并更改 DNS 服务器。</li>\\n<li><strong>国际化支持</strong>：实现 Vitepress 和评论系统 Giscus 的国际化，支持中英双语。</li>\\n<li><strong>内容迁移</strong>：对博客文章进行迁移，生成摘要和标签，确保旧路径的兼容性以避免外链失效。</li>\\n<li><strong>优化用户体验</strong>：自定义字体并进行预加载，提升页面加载速度。</li>\\n</ol>\\n<p>通过这些调整，笔者希望博客不仅在内容上丰富，同时在视觉和使用体验上也能给读者带来更好的感受。最终，笔者强调了博客设计对写作心情的重要性，认为整理环境能够促进创作灵感的流动。</p>\\n","date":{"time":1722340800000,"string":"2024/07/30","year":"2024年","monthDay":"07/30"},"tags":["博客","Vitepress","Cloudflare","Giscus","RSS","TDesign"]},{"title":"如何讨好读者/观众","url":"/posts/2024/04/28如何讨好读者或观众","excerpt":"<p>如何讨好读者/观众的关键在于理解生理机制对写作的影响。</p>\\n<p>技术写作不仅需要技术知识，还需掌握写作技巧。</p>\\n<ul>\\n<li>通过激发肾上腺素，创造紧迫感，能让读者更有动力阅读；</li>\\n<li>利用镜像神经元，增加代入感，帮助读者沉浸于内容中；</li>\\n<li>通过 GABA 的作用，使文章结尾给人以豁然开朗的感觉；</li>\\n<li>多巴胺则通过奖励机制，激励读者继续关注内容；</li>\\n</ul>\\n<p>最后，催产素通过情感故事，增强读者的情感共鸣。优秀的内容创作需要将这些元素结合，以吸引和维持观众的兴趣。</p>\\n","date":{"time":1714305600000,"string":"2024/04/28","year":"2024年","monthDay":"04/28"},"tags":["写作","观众","读者"]},{"title":"最近 GPT 帮我解决的 30 个问题","url":"/posts/2024/04/18最近GPT帮我解决的30个问题","excerpt":"<p>最近，我发现自己越来越依赖 GPT（大型语言模型）来解决一些问题，这些问题涉及到编程、工作、学习等方方面面。GPT 不仅可以帮助我快速生成代码，还可以提供一些有趣的想法和解决方案。在这篇文章中，我将分享最近 GPT 帮我解决的 30 个问题，希望能给大家一些启发。</p>\\n<p>比如：</p>\\n<ul>\\n<li>生成 GitHub README 的热词词云图</li>\\n<li>生成 Excel 转 JSON 的函数</li>\\n<li>生成 GPT 翻译 HTML 的程序</li>\\n<li>生成时间处理函数</li>\\n<li>生成 CSS 磨砂玻璃效果</li>\\n<li>生成 Windows 查看端口占用的命令</li>\\n<li>辅助阅读代码</li>\\n<li>等等...</li>\\n</ul>\\n","date":{"time":1713441600000,"string":"2024/04/18","year":"2024年","monthDay":"04/18"},"tags":["GPT","编程","工作","学习"]},{"title":"又一次开始学英语了，希望这次能享受它","url":"/posts/2024/02/18又一次开始学英语了，希望这次能享受它","excerpt":"<p>这篇文章讲述了作者再次开始学习英语的心态和目标。</p>\\n<p>作者通过观看一段关于学习外语的油管视频，了解到好奇和放松的心理状态对于学习的重要性。视频中介绍了五个原则和七个行为，包括聚焦在与自己相关的语言内容上、将语言作为沟通工具、通过理解消息来学习语言、说出让别人听懂的语言、保持好心情和放松状态等。</p>\\n<p>作者还分享了一些学习英语的方法和资源，包括观看外文视频和阅读外文博客。最后，作者希望能够真正享受学习英语的过程，并将其作为一种习惯和工具来使用。</p>\\n","date":{"time":1708257600000,"string":"2024/02/18","year":"2024年","monthDay":"02/18"},"tags":["英语","学习","油管","视频","教程"]},{"title":"Nuxt3 手写一个搜索页面","url":"/posts/2024/01/26Nuxt3手写一个搜索页面","excerpt":"<p>笔者在这篇文章中分享了对之前开发的小型搜索引擎的前端重构过程，主要使用了<code>Nuxt</code>和<code>Vuetify</code>技术栈。重写的动机包括代码结构混乱、后端服务冗余以及希望通过 SSR（服务器端渲染）优化 SEO。通过重构，用户在搜索时，URL 会根据查询更新，从而提升搜索引擎的抓取效果，增加应用的曝光率。</p>\\n<p>页面布局上，笔者注重移动端优化，同时保持搜索框和结果在同一页面，简化用户体验。后端使用了两个 API 接口，分别处理搜索请求和搜索建议。笔者强调了使用<code>Nuxt</code>时开发体验的优越性，特别是在快速搭建 API 方面。</p>\\n<p>代码结构上，笔者通过组件封装简化了主页面的复杂性，并动态生成 SEO 相关的元信息，以便于分享时的展示效果。此外，文章提到集成了 Google 和百度的分析工具，便于后续的数据追踪。</p>\\n<p>总的来说，笔者对<code>Nuxt</code>的使用体验表示满意，并鼓励读者尝试这款技术。</p>\\n","date":{"time":1706270400000,"string":"2024/01/26","year":"2024年","monthDay":"01/26"},"tags":["Nuxt","Vuetify","SSR","SEO","API","Analytics","Elasticsearch"]},{"title":"写个 docker+nginx 部 https 的模板","url":"/posts/2024/01/12写个docker+nginx部https的模板","excerpt":"<p>笔者在这篇文章中分享了一个基于<code>nginx + docker</code>的<code>https</code>模板，旨在简化国内用户自建小网站的部署过程。考虑到国内缺乏便捷的免费部署平台，笔者创建了一个易于使用的模板和相应的脚本，以便快速实现<code>https</code>反向代理。</p>\\n<p>使用该模板的基本步骤包括：</p>\\n<ol>\\n<li>克隆模板项目到本地。</li>\\n<li>替换证书文件为自己的证书。</li>\\n<li>运行脚本以替换域名。</li>\\n<li>根据需要修改<code>docker-compose.yml</code>中的根目录。</li>\\n<li>启动 Docker 容器。</li>\\n</ol>\\n<p>最后，笔者建议使用<code>docker ps</code>命令检查容器状态，并查看<code>nginx</code>日志以确保服务正常运行。总的来说，这个模板为用户提供了一个快速、方便的方式来部署<code>https</code>网站。</p>\\n","date":{"time":1705060800000,"string":"2024/01/12","year":"2024年","monthDay":"01/12"},"tags":["docker","nginx","https","shell","deploy"]},{"title":"天冷了，笔记本也需要保暖了","url":"/posts/2024/01/03天冷了，笔记本也需要保暖了","excerpt":"<p>笔者在寒冷天气中重新使用了一台五年的游戏笔记本，却发现其电量显示为 0 并无法充电。经过一番搜索，笔者意识到问题可能与低温有关，锂电池在接近零度时充电困难，主要是因为锂离子移动速度降低及电解液粘度增大。最终，笔者找到了一种简单的解决方案——用暖水袋加热笔记本底部，成功解决了充电问题。此事件提醒我，长时间未使用的设备在寒冷环境下需特别注意保暖和充电，确保其正常运作。通过这次经历，笔者进一步了解了锂电池在低温下的工作原理，也为今后做好设备保养积累了经验。</p>\\n","date":{"time":1704283200000,"string":"2024/01/03","year":"2024年","monthDay":"01/03"},"tags":["笔记本","电池","低温","保暖","充电","锂电池"]},{"title":"股票基金常用指标、方法解释","url":"/posts/2023/12/11股票基金常用指标、方法解释","excerpt":"<p>在我最近学习股票基金的过程中，整理了一些常用的投资指标和计算方法，帮助我更好地理解这个领域。首先，市盈率（P/E）和市净率（P/B）是两个关键的估值指标，前者反映了市场对公司未来盈利能力的预期，而后者则评估了投资者对公司账面价值的支付意愿。接着，ROE 和股息率等指标则分别评估了企业的运营效率和股东回报情况。此外，PEG 比率将市盈率与预期盈利增长率结合，为投资者提供了更全面的价值评估视角。现金流收益率和盈利收益率法则为投资决策提供了实用的指导原则，而博格公式法则强调了长期盈利增长与市盈率的关系。通过理解这些公式及其背后的含义，可以更有效地进行投资决策。</p>\\n","date":{"time":1702296000000,"string":"2023/12/11","year":"2023年","monthDay":"12/11"},"tags":["股票","基金","投资","指标","方法"]},{"title":"游标分页较传统分页的优势以及详细实现","url":"/posts/2023/11/29游标分页较传统分页的优势以及详细实现","excerpt":"<p>笔者在这篇文章中探讨了游标分页相较于传统分页的优势及其具体实现。在处理大量数据时，分页技术可以显著提升用户体验和应用性能。传统分页基于页数和项目数量，虽然实现简单且用户友好，但在大数据量下可能导致性能下降和数据一致性问题。因此，游标分页应运而生。</p>\\n<p>游标分页的关键在于基于上一页最后一个项目进行数据加载，避免了高<code>OFFSET</code>带来的性能损失，并且即使在数据插入的情况下，也能保持页面内容的一致性。然而，游标分页的实现相对复杂，且用户无法直接跳转到任意页面，这可能影响用户体验。</p>\\n<p>笔者通过<code>Nest.js</code>和<code>GraphQL</code>提供了游标分页的详细实现代码示例，强调了在不同业务需求下选择合适分页方式的重要性。对于需要快速响应的移动端应用，游标分页无疑是一个更优的选择。</p>\\n","date":{"time":1701259200000,"string":"2023/11/29","year":"2023年","monthDay":"11/29"},"tags":["游标分页","传统分页","数据库","GraphQL","Nest.js"]},{"title":"在 uniapp 中使用 GraphQL 的一些探索","url":"/posts/2023/11/14在uniapp中使用GraphQL的一些探索","excerpt":"<p>笔者在这篇文章中分享了在 uniapp 中使用 GraphQL 的探索过程。首先提到，虽然 GraphQL 在 nest.js 等服务端应用中有丰富的资料，但在 uniapp 的技术栈中相对匮乏。因此，笔者介绍了如何利用一个名为 Villus 的小库来实现与 Vue 的响应式结合，简化 GraphQL 的使用。</p>\\n<p>接着，笔者详细说明了如何将 Villus 的 fetch 请求替换为 uni.request，以适配 uniapp 的网络请求方式。通过创建 setup.ts 文件并重写 fetch，成功实现了 uniapp 中 GraphQL 的请求功能。此外，笔者还建议将 GraphQL 查询字符串单独封装，提高代码的可读性和管理性，并展示了如何在组件中实际使用这些封装好的查询。</p>\\n<p>最后，笔者希望能为国内的 uniapp 与 GraphQL 结合提供一些参考，并期待与读者的讨论。</p>\\n","date":{"time":1699963200000,"string":"2023/11/14","year":"2023年","monthDay":"11/14"},"tags":["uniapp","GraphQL","Vue","Villus","fetch","setup"]},{"title":"看看 openai 发布会","url":"/posts/2023/11/08看看openai发布会","excerpt":"<p>笔者在这篇文章中探索了如何在 uniapp 中使用 GraphQL，尤其是结合 Vue 和 Vite 的环境。首先，笔者提到使用了一个名为<code>Villus</code>的库，它与 Vue 的响应式特性结合良好，使得 GraphQL 查询的使用变得优雅。接着，笔者详细介绍了如何将<code>Villus</code>的默认网络请求方式替换为 uniapp 的<code>uni.request</code>，以适应小程序的环境，并提供了具体的代码示例。</p>\\n<p>此外，笔者还建议将 GraphQL 查询字符串封装到单独的文件中，以便于管理和维护，展示了如何创建一个组织良好的模块结构。最后，通过一个实际的组件示例，笔者展示了如何应用上述封装的 GraphQL 查询，强调了在国内技术栈中关于 GraphQL 的学习和实践的重要性。这些探索希望能为其他开发者提供参考和帮助。</p>\\n","date":{"time":1699444800000,"string":"2023/11/08","year":"2023年","monthDay":"11/08"},"tags":["openai","GPT-4 Turbo","API","Assistant","GPTs"]},{"title":"搞个域名邮箱玩玩（如`just@justin3go.com`）","url":"/posts/2023/11/01搞个域名邮箱玩玩（如just@justin3go.com）","excerpt":"<p>笔者一直觉得常用的邮箱后缀如 <code>@qq.com</code> 和 <code>@gmail.com</code> 不够高级，因此决定尝试创建一个专属的域名邮箱 <code>just@justin3go.com</code>。这个邮箱主要用于接收个人博客和正式场合的重要信息，而普通注册则继续使用之前的邮箱，以避免广告信息的干扰。</p>\\n<p>创建过程相对简单，笔者选择在阿里云进行域名解析，并使用腾讯企业邮作为邮箱服务。通过域名解析控制台，轻松绑定了域名与企业邮箱。注册后，等待域名审核成功，便可以使用自己的域名邮箱。</p>\\n<p>最后，笔者将邮箱绑定到开源客户端 Thunderbird，成功发送了一封测试邮件，整个过程顺利完成。虽然十月没有更新博客，但通过这个项目，笔者感到非常满足。</p>\\n","date":{"time":1698840000000,"string":"2023/11/01","year":"2023年","monthDay":"11/01"},"tags":["邮箱","域名","阿里云","腾讯企业邮","Thunderbird"]},{"title":"vitepress 中引入 tdesign 并全局增加大图预览","url":"/posts/2023/09/29vitepress中引入Tdesign并全局增加大图预览","excerpt":"<p>笔者在这篇文章中分享了如何在 VitePress 中引入 TDesign 组件库并为博客图片增加大图预览功能。首先，笔者选择 TDesign 作为 UI 组件库，并根据官方文档进行配置，特别是 VitePress 的配置文件 config.ts。接着，笔者介绍了如何结合 TDesign 实现深色和浅色模式的切换，使用<code>isDark</code>响应式变量来监听主题变化。</p>\\n<p>为了实现图片预览，笔者提供了详细的步骤：找到页面中的所有图片，监听其点击事件，并为每个点击事件绑定大图预览效果。代码示例展示了如何在 Vue 组件中处理这些逻辑，包括显示预览的组件和相关的样式设置。通过这些步骤，笔者成功为自己的博客添加了便捷的图片预览功能，感叹在博客建设中的乐趣和挑战。</p>\\n","date":{"time":1695988800000,"string":"2023/09/29","year":"2023年","monthDay":"09/29"},"tags":["vitepress","tdesign","大图预览","深色模式","浅色模式"]},{"title":"自托管项目工具 plane 管理自己的 TodoList","url":"/posts/2023/09/29自托管项目工具plane管理自己的TodoList","excerpt":"<p>笔者最近发现了一个名为<code>plane</code>的开源项目管理工具，作为 Jira 的替代品，后端使用 Django 框架。经过简单的部署，笔者将其用于管理自己的 TodoList。部署过程相对简单，主要依赖 Docker，按照官方文档的指示进行操作，同时确保了 HTTPS 的安全性。</p>\\n<p>在配置 NGINX 时，笔者特别设置了不同的端口以避免冲突，并在<code>docker-compose.yml</code>文件中定义了服务的结构。通过配置 SSL 证书，笔者成功实现了 HTTP 到 HTTPS 的重定向。为了保持系统的优雅性，笔者选择了通过 NGINX 代理进行解耦，而不是直接修改<code>plane</code>的源代码。</p>\\n<p>在使用上，笔者将每年的计划视为一个项目，并利用标签和视图功能对 TodoList 进行分类和过滤。尽管<code>plane</code>仍存在一些 bug，笔者对其未来的改进充满期待，并希望在使用中找到更高效的管理方式。</p>\\n","date":{"time":1695988800000,"string":"2023/09/29","year":"2023年","monthDay":"09/29"},"tags":["plane","TodoList","Django","Docker","HTTPS"]},{"title":"vitepress 中增加 twitter/x 卡片","url":"/posts/2023/09/28vitepress中增加twitter卡片","excerpt":"<p>笔者最近分享了如何在 VitePress 中为博客添加 Twitter/X 卡片功能，以便在分享链接时显示更丰富的内容。首先，需要在页面的 HEAD 部分添加特定的 HTML 标记，定义卡片的类型和相关属性。每个页面只支持一种卡片类型，且属性需要动态生成。为此，VitePress 提供了<code>transformHead</code>钩子，使得开发者可以在生成页面时自定义 HEAD 信息。</p>\\n<p>具体实现步骤包括：在配置文件中引入<code>transformHead</code>钩子，获取页面信息（如标题、描述和相对路径），并组装成需要的<code>HeadConfig[]</code>格式返回。笔者提供了详细代码示例，帮助读者轻松实现这一功能。最后，若在 Twitter 中未能正确显示卡片，建议清除缓存并参考 Twitter 开发者文档进行排查。</p>\\n","date":{"time":1695902400000,"string":"2023/09/28","year":"2023年","monthDay":"09/28"},"tags":["vitepress","twitter","x 卡片","meta","transformHead"]},{"title":"原来 Vue.js 还有这么多好用的 UI 组件库","url":"/posts/2023/08/31原来Vue还有这么多好用的UI库","excerpt":"<p>在这篇博客中，笔者通过对一段推文的探讨，深入研究了多个优秀的 Vue.js UI 组件库，并分享了自己的发现。笔者认为，尽管 Vue.js 的组件库数量可能不如 React 丰富，但仍有不少值得关注的选项。以下是一些推荐的库：</p>\\n<ul>\\n<li><strong>PrimeVue</strong>：提供超过 90 个高质量组件，易于定制和使用。</li>\\n<li><strong>Headless UI</strong>：无样式组件，完美集成 Tailwind CSS。</li>\\n<li><strong>Vuetify</strong>：基于 Material Design 规范，灵活且社区活跃。</li>\\n<li><strong>Quasar</strong>：一站式解决方案，支持多平台开发。</li>\\n<li><strong>Radix-Vue</strong>：兼容 Vue 和 Nuxt，注重可访问性和开发者体验。</li>\\n<li><strong>DaisyUI</strong>：为 Tailwind CSS 提供组件类名，简化开发。</li>\\n</ul>\\n<p>最后，笔者提到国内也有诸多优秀组件库，如 element-plus 和 vant 等，最终决定在 Vuetify 和 Quasar 之间进行选择。</p>\\n","date":{"time":1693483200000,"string":"2023/08/31","year":"2023年","monthDay":"08/31"},"tags":["Vue.js","UI 组件库","PrimeVue","Headless UI","Vuetify","Quasar","Radix-Vue","DaisyUI"]},{"title":"你来你也可以做一个网盘搜索引擎","url":"/posts/2023/08/29你来你也可以做一个网盘搜索引擎","excerpt":"<p>在这篇文章中，笔者分享了他在过去两年间的一个小型网盘搜索引擎项目，以复习和实践搜索引擎的相关知识。</p>\\n<p>项目使用了多个技术栈，包括 Scrapy、ElasticSearch、NestJS 和 VueJS，整体架构相对简化。</p>\\n<p>笔者详细描述了爬虫的实现思路，从种子网站爬取网盘资源并使用正则表达式提取链接，最终将数据索引到 ElasticSearch 中。文章还提到在部署过程中遇到的 IP 管理问题，提醒读者注意安全设置。后端部分提供了简单的搜索和建议接口，而前端则使用了腾讯的 UI 库，构建了一个用户友好的搜索界面。项目没有开源的计划，并且笔者认为这个过程为他提供了宝贵的实践经验。</p>\\n","date":{"time":1693310400000,"string":"2023/08/29","year":"2023年","monthDay":"08/29"},"tags":["网盘","搜索引擎","Scrapy","ElasticSearch","NestJS","VueJS","Docker"]},{"title":"Web 架构 JAMStack“以动制静”","url":"/posts/2023/08/22Web架构JAMStack“以动制静”","excerpt":"<p>笔者在阅读《微前端设计与实现》时，发现了 JAMStack 这一概念，尽管最初认为它是新奇的，但经过研究后意识到其实它是对静态网页的一种扩展。静态网页的特点在于内容固定、加载速度快、易于部署且安全性高，然而在交互性和更新方面存在一定的局限性。</p>\\n<p>JAMStack 则通过“以动制静”的方式，将动态内容生成静态网页，利用静态网页生成器和前端框架，结合无服务功能，实现更快的加载速度和更高的安全性。尽管 JAMStack 有诸多优势，但在实时交互、数据更新和技术门槛等方面也面临挑战。笔者设想结合 vitepress 和 Node.js，构建一个内容管理平台，以实现更优雅的静态网页生成方式。</p>\\n","date":{"time":1692705600000,"string":"2023/08/22","year":"2023年","monthDay":"08/22"},"tags":["JAMStack","静态网页","动态网页","静态网页生成","静态网页生成器","无服务功能","vitepress","Node.js"]},{"title":"给 vitepress 增加短链接生成功能","url":"/posts/2023/08/18给vitepress增加短链接生成功能","excerpt":"<p>笔者在这篇文章中介绍了为 VitePress 博客增加短链接生成功能的过程。最初，笔者希望通过语义化 URL 来优化链接，但由于包含中文字符的长链接变得过于复杂，决定实现短链接以便于分享。短链接的生成采用 MD5 截断算法，确保同一 URL 生成的短链接始终一致。笔者实现了长链接与短链接之间的映射，并通过递归遍历 VitePress 的侧边栏生成链接。</p>\\n<p>此外，笔者创建了一个跳转页面和一个复制短链接的按钮，使用户可以方便地获取短链接。这些功能的实现充分利用了 VitePress 的高扩展性，笔者通过简单的代码示例展示了具体实现。最终，笔者希望通过这种方式提升博客的分享体验，并计划每月写至少四篇博客。</p>\\n","date":{"time":1692360000000,"string":"2023/08/18","year":"2023年","monthDay":"08/18"},"tags":["vitepress","短链接","MD5","截断","递归","侧边栏"]},{"title":"浅谈搜索引擎原理","url":"/posts/2023/08/17浅谈搜索引擎原理","excerpt":"<p>笔者在这篇文章中回顾了搜索引擎的基本结构和工作原理，旨在帮助读者扩展相关知识。搜索引擎的架构可分为离线系统和在线系统，前者负责数据收集、清洗和索引，后者则进行用户交互和搜索结果的返回。爬虫策略的选择至关重要，通常采用广度优先爬取以获取重要网页。</p>\\n<p>在处理网页内容时，笔者强调了结构化内容提取和网页去重的重要性。PageRank 算法被提及作为评估网页质量的经典方法，而倒排索引则是实现高效检索的关键技术。最后，笔者简要描述了搜索模块的工作流程，从用户输入搜索词到结果返回，强调了用户体验的重要性。总的来说，本文为理解搜索引擎的运作提供了一个清晰的框架。</p>\\n","date":{"time":1692273600000,"string":"2023/08/17","year":"2023年","monthDay":"08/17"},"tags":["搜索引擎","爬虫","倒排索引","PageRank","搜索模块"]},{"title":"(译)面向 JavaScript 开发人员的 Docker 简介（Node.js 和 PostgreSQL）","url":"/posts/2023/07/26(译)面向JavaScript开发人员的Docker简介（Node.js 和 PostgreSQL）","excerpt":"<p>笔者在这篇文章中介绍了 Docker 的基本概念及其对 JavaScript 开发者的价值，尤其是在构建 Node.js 和 PostgreSQL 全栈应用时的应用场景。文章强调了 Docker 通过容器化技术解决了开发环境一致性的问题，使得开发者能够在不同设备上快速部署应用，而无需担心依赖和版本不兼容的问题。</p>\\n<p>通过实际示例，笔者展示了如何创建一个 Node.js 应用程序，使用 Dockerfile 构建镜像，并通过 Docker Compose 来管理多容器应用，包括连接 PostgreSQL 数据库。文章还详细介绍了 Docker 的命令行操作、镜像和容器的管理，以及如何使用卷(VOL)实现文件同步，确保开发过程的高效性。</p>\\n<p>最后，笔者鼓励开发者深入学习 Docker，并利用其强大特性来简化开发环境的搭建与管理，从而提升开发效率与协作能力。</p>\\n","date":{"time":1690372800000,"string":"2023/07/26","year":"2023年","monthDay":"07/26"},"tags":["Docker","JavaScript","Node.js","PostgreSQL","Dockerfile","Docker Compose"]},{"title":"前端双 token 策略(uniapp-vue3-ts 版)","url":"/posts/2023/07/02前端双token策略(uniapp-vue3-ts版)","excerpt":"<p>在这篇文章中，笔者探讨了前端双 token 策略的实现，特别是在使用 uniapp 和 Vue 3 的环境下。</p>\\n<p>双 token 策略主要通过<code>access token</code>和<code>refresh token</code>来降低 JWT 泄露的风险，确保用户体验流畅。</p>\\n<p>具体流程包括：</p>\\n<ol>\\n<li>首先检查<code>access token</code>是否过期，若未过期则直接使用；</li>\\n<li>若已过期，则检查<code>refresh token</code>的有效性，若有效则请求新的<code>access token</code>并更新存储；</li>\\n<li>若<code>refresh token</code>也过期，则需要用户重新登录。</li>\\n</ol>\\n<p>为了实现这一策略，笔者提供了一系列通用函数和拦截器代码，确保在每次请求中自动处理 token 的状态。此外，文章还介绍了如何实现<code>atob</code>函数，以便解码 JWT 并获取相关信息。通过这些实现，双 token 策略的应用不仅提升了安全性，还优化了用户体验。</p>\\n","date":{"time":1688299200000,"string":"2023/07/02","year":"2023年","monthDay":"07/02"},"tags":["uniapp","Vue 3","TypeScript","JWT","Pinia","GraphQL"]},{"title":"给 vitepress 博客里增加一个 RSS 订阅","url":"/posts/2023/06/18vitepress博客里增加一个RSS订阅","excerpt":"<p>笔者最近在优化自己的 VitePress 博客时，增加了一个 RSS 订阅功能，以便更好地满足日益增长的阅读需求。为此，我选择了开源的 RSS 阅读软件 Fluent Reader，并鼓励读者分享他们的推荐软件。文章详细介绍了如何使用 RSS，强调其主动获取信息的优势，并提供了在 VitePress 中创建 RSS 的具体步骤。</p>\\n<p>通过使用<code>feed</code> npm 包，笔者展示了如何生成符合 RSS 标准的 XML 文件。具体步骤包括读取所有文章列表、生成 RSS 条目，并在<code>buildEnd</code>钩子中调用生成函数。示例代码中展示了如何提取日期、标题及内容，确保仅保留最近三篇文章。最后，笔者邀请读者访问其开源仓库，期待大家的关注与反馈。</p>\\n","date":{"time":1687089600000,"string":"2023/06/18","year":"2023年","monthDay":"06/18"},"tags":["VitePress","RSS","Fluent Reader","feed","buildEnd"]},{"title":"简单优化一下个人博客首页(迁移 vitepress-beta 版)","url":"/posts/2023/06/06简单优化下个人博客首页(迁移vitepress-beta版)","excerpt":"<p>笔者在这篇博客中分享了将个人博客从 VitePress alpha 版本迁移到 beta 版本的过程，并进行了首页样式的优化。</p>\\n<p>迁移的主要原因是 beta 版本提供了更稳定的体验和官方本地搜索功能，取代了之前使用的第三方插件。</p>\\n<p>此外，笔者将评论系统从 Gitalk 替换为 Giscus，因其界面更美观且功能丰富，如开源、无需数据库等。博客首页还实现了视频自适应背景和最近发布文章的展示，旨在提升用户体验。通过简单的递归遍历侧边栏数据，笔者提取最近的 10 篇文章。同时，笔者分享了 CI/CD 的配置，确保博客的自动化部署。整个过程不仅展示了技术细节，也体现了笔者对博客优化的热情与坚持。</p>\\n","date":{"time":1686052800000,"string":"2023/06/06","year":"2023年","monthDay":"06/06"},"tags":["VitePress","个人博客","优化","迁移","Giscus","CI/CD"]},{"title":"哪一个权限控制模型呢？(DAC|MAC|RBAC|RuBAC|ABAC)","url":"/posts/2023/05/11该给系统加哪一个权限控制模型呢","excerpt":"<p>笔者在本文中详细探讨了几种常见的权限控制模型，包括</p>\\n<ul>\\n<li>自主访问控制（DAC）</li>\\n<li>强制访问控制（MAC）</li>\\n<li>基于角色的访问控制（RBAC）</li>\\n<li>基于规则的访问控制（RuBAC）</li>\\n<li>基于属性的访问控制（ABAC）</li>\\n</ul>\\n<p>每种模型都有其适用场景和优缺点。例如，DAC 允许用户自主管理权限，但管理难度较大；而 MAC 则由管理员统一控制，适合安全要求较高的场景。RBAC 通过角色解耦使权限管理变得更加灵活，RuBAC 则允许在角色基础上添加特定规则，提供更细致的控制。</p>\\n<p>笔者结合自身小程序的需求，认为 RBAC0 与 RuBAC 的混合模型最为合适，使得权限管理既简便又有效。总之，选择合适的权限控制模型需要根据具体业务场景进行灵活应用。</p>\\n","date":{"time":1683806400000,"string":"2023/05/11","year":"2023年","monthDay":"05/11"},"tags":["权限控制","DAC","MAC","RBAC","RuBAC","ABAC"]},{"title":"PIXIJS 快速一览","url":"/posts/2023/05/09PIXIJS快速一览","excerpt":"<p>笔者在这篇文章中介绍了 PIXIJS，一个快速、轻量、开源的渲染引擎，适合前端开发者用于创建小游戏和动画效果。文章强调 PIXIJS 并非一个完整的游戏开发框架，而是专注于图像和动画的呈现。笔者通过简单的示例代码说明了 PIXIJS 的基本构建块，包括应用舞台、精灵、容器和纹理等。</p>\\n<p>此外，笔者阐述了容器的角色，它帮助组织舞台中的对象，提供了遮罩和滤镜功能。对于图形的创建，笔者提供了示例代码，并提醒开发者在使用后注意卸载以避免内存泄漏。文章还提到交互和文本处理的基本知识，强调性能优化的重要性。最后，笔者鼓励读者通过实践来深化对 PIXIJS 的理解，并欢迎反馈以改进自己的学习。</p>\\n","date":{"time":1683633600000,"string":"2023/05/09","year":"2023年","monthDay":"05/09"},"tags":["PIXIJS","游戏开发","动画效果","前端开发","渲染引擎"]},{"title":"两个多月捣鼓了一个健康类小程序","url":"/posts/2023/05/07两个多月捣鼓了一个健康类小程序","excerpt":"<p>笔者在两个月的时间里成功开发了一个以心理健康为主题的小程序，主要功能已完成，虽然仍有待改进，但整体体验令人满意。项目旨在通过“互联网+心理健康”的方式，解决青少年面临的心理健康问题，特别是普及、发现和解决三大痛点。小程序的创新之处在于通过朋友间互相填写问卷的方式，结合自身与他人的评价，帮助用户更好地认识自己的心理状态。</p>\\n<p>在技术实现上，笔者采用了现代化的前后端技术栈，包括 Vue.js、Nest.js 等，此外还引入了 AI 智能问答功能，形成发现与解决问题的闭环。尽管项目仍处于迭代阶段，笔者对未来的商业化和功能扩展充满期待，计划引入更多的心理咨询资源和社交功能，以提升用户体验和价值。</p>\\n","date":{"time":1683460800000,"string":"2023/05/07","year":"2023年","monthDay":"05/07"},"tags":["小程序","心理健康","互联网+","问卷调查","AI","Vue.js","Nest.js"]},{"title":"Nest 的 test 中的 best 是 Jest 框架","url":"/posts/2023/05/01Nest的test中的best是Jest框架","excerpt":"<p>在这篇文章中，笔者分享了自己在五一假期期间为一个小系统补充单元测试的经验，特别是使用 Jest 框架进行测试的过程和技巧。</p>\\n<p>单元测试被定义为对软件系统中的最小可测试单元进行验证，笔者通过生动的比喻强调了单元测试的重要性，例如将其比作小学数学题的验算。文章详细介绍了单元测试的好处，如提高代码质量、可维护性和可读性，并阐述了单元测试的相关概念和覆盖率指标。</p>\\n<p>此外，笔者还提供了在 Nest 框架中配置 Jest 的具体步骤，以及如何使用 Mock 技术避免直接操作数据库。最后，笔者展示了如何在持续集成中自动化测试，确保代码质量。在整个过程中，笔者用轻松幽默的风格，鼓励读者重视单元测试的实践。</p>\\n","date":{"time":1682942400000,"string":"2023/05/01","year":"2023年","monthDay":"05/01"},"tags":["单元测试","Jest","Nest","Mock","持续集成"]},{"title":"试下微调 GPT-3 做一个心理问答机器人","url":"/posts/2023/04/26试下微调GPT-3做一个心理问答机器人","excerpt":"<p>笔者在这篇文章中分享了如何利用 GPT-3 微调创建一个心理问答机器人。</p>\\n<ul>\\n<li>首先，笔者选择了 Google Colab 作为开发环境，避免了复杂的本地环境配置</li>\\n<li>接着，笔者详细介绍了如何安装 OpenAI 命令行工具并设置 API_KEY，确保能够调用 GPT-3 服务</li>\\n<li>数据集的准备至关重要，笔者使用了两份公开的中文心理问答数据集，并将其转换为符合<code>jsonl</code>格式的问答对</li>\\n<li>上传数据后，笔者通过简单的命令开始微调模型，并展示了如何在微调完成后进行调用</li>\\n</ul>\\n<p>尽管结果尚可接受，但由于数据量较小，效果有限。最后，笔者表达了对未来 API 的期待，并回忆起学习 Python 的初衷。整个过程不仅展示了技术实现，也反映了笔者的学习与探索精神。</p>\\n","date":{"time":1682510400000,"string":"2023/04/26","year":"2023年","monthDay":"04/26"},"tags":["GPT-3","微调","问答","Colab","OpenAI","Python"]},{"title":"Nest 如何实现带身份验证的 GraphQL 订阅 Subscription","url":"/posts/2023/04/23Nest如何实现带身份验证的GraphQL订阅Subscription","excerpt":"<p>笔者在这篇文章中分享了在 Nest.js 中实现带身份验证的 GraphQL 订阅功能的步骤与配置。</p>\\n<ul>\\n<li>首先，推荐使用<code>graphql-redis-subscriptions</code>替代默认的<code>PubSub</code>，以支持生产环境的多机部署。</li>\\n<li>接着，通过创建<code>PubsubModule</code>并配置 Redis 连接，笔者详细展示了如何在<code>App.module</code>中整合身份验证模块和 GraphQL 模块。</li>\\n<li>随后，笔者提供了<code>GqlConfigService</code>的实现，重点在于如何在<code>onConnect</code>中进行 WebSocket 身份验证，并将用户信息附加到上下文中。为了确保接口的安全性，笔者自定义了 JWT 身份验证装饰器和用户实体装饰器。</li>\\n<li>最后，笔者在一个 Resolver 中演示了如何使用这些配置，确保只有经过身份验证的用户才能进行订阅和相关操作。整体而言，文章内容详实，适合需要实现 GraphQL 订阅的开发者参考。</li>\\n</ul>\\n","date":{"time":1682251200000,"string":"2023/04/23","year":"2023年","monthDay":"04/23"},"tags":["Nest.js","GraphQL","订阅","身份验证","WebSocket"]},{"title":"Vue3+TS(uniapp)手撸一个聊天页面","url":"/posts/2023/04/20Vue3+TS(uniapp)手撸一个聊天页面","excerpt":"<p>笔者最近在开发一个智能客服的小程序，决定使用 Vue3 和 TypeScript（uniapp）手动实现一个聊天页面。</p>\\n<p>文章详细介绍了实现过程中的关键点，包括如何编写聊天气泡、输入框和保持滚动条在底部。气泡的实现使用了 CSS 伪类来创建小箭头，并通过<code>max-width</code>限制宽度。输入框则采用了<code>&lt;textarea&gt;</code>标签以支持多行输入，并通过<code>scroll-view</code>组件实现自动滚动。笔者还探讨了消息存储和推荐功能的实现，利用 GraphQL 接口获取用户输入的推荐消息，并展示在聊天界面中。</p>\\n<p>最后，笔者分享了一些思考，虽然未实现消息的本地存储，但提出了基于链表的数据结构存储建议。整体而言，项目展示了 Vue 与 uniapp 结合的强大灵活性。</p>\\n","date":{"time":1681992000000,"string":"2023/04/20","year":"2023年","monthDay":"04/20"},"tags":["Vue3","TypeScript","uniapp","聊天页面","GraphQL","智能客服"]},{"title":"我终于会用 Docker 了(nest+prisma+psotgresql+nginx+https)","url":"/posts/2023/04/17我终于会用Docker了(nest+prisma+psotgresql+nginx+https)","excerpt":"<p>笔者在这篇文章中分享了自己使用 Docker 进行 NestJS 后端服务部署的实践经历。文章首先介绍了 Docker 的基本概念和优势，比如简化应用部署和跨平台的可移植性。随后，笔者列出了常用的 Docker 命令并详细解释了 Dockerfile 和 docker-compose.yml 的编写过程，以实现 NestJS、PostgreSQL 和 Nginx 的整合部署。</p>\\n<p>在实战部分，笔者提供了项目目录结构、Dockerfile 示例以及 docker-compose 配置，强调了持久化存储和环境变量的使用。此外，笔者还分享了在使用 Prisma 时遇到的一个小问题，提醒读者注意容器间的连接配置。</p>\\n<p>整体而言，本文不仅是对 Docker 基础知识的回顾，也展示了实际操作中的一些细节与坑点，旨在帮助读者更好地理解和应用 Docker 技术。希望对大家的部署工作有所帮助。</p>\\n","date":{"time":1681732800000,"string":"2023/04/17","year":"2023年","monthDay":"04/17"},"tags":["docker","nest","prisma","postgresql","nginx","https"]},{"title":"小程序(uniapp)上传头像至 OSS(阿里云)--保姆级","url":"/posts/2023/04/05实现微信小程序(uniapp)上传头像至阿里云oss","excerpt":"<p>笔者在这篇博客中详细介绍了如何将用户头像上传至阿里云 OSS 的过程，特别是在微信小程序改版后，获取用户头像和昵称的必要性。整个流程主要包含五个步骤：</p>\\n<ol>\\n<li>使用微信组件获取用户选择的头像的临时路径；</li>\\n<li>获取阿里云 OSS 的操作授权；</li>\\n<li>配置后端服务生成临时授权的服务；</li>\\n<li>上传文件至 OSS；</li>\\n<li>将头像路径保存到数据库用户表中。</li>\\n</ol>\\n<p>笔者提供了详细的代码示例和配置步骤，特别是如何使用 NestJS 与 GraphQL 进行后端服务的设置，以及如何通过环境变量安全管理阿里云的凭证。最后，笔者强调了小程序开发在用户体验中的重要性，并鼓励读者在遇到问题时进行讨论和交流。希望这篇<strong>保姆级教程</strong>能对开发者们有所帮助。</p>\\n","date":{"time":1680696000000,"string":"2023/04/05","year":"2023年","monthDay":"04/05"},"tags":["小程序","uniapp","阿里云","OSS","NestJS","GraphQL","TypeScript"]},{"title":"(极简)给个人博客添加订阅功能","url":"/posts/2023/03/31极简地给个人博客添加订阅功能","excerpt":"<p>笔者今天分享了一种极简的个人博客订阅功能实现方式，主要是通过 GitHub 的 Issue 来完成。</p>\\n<p>当前主流的订阅方式包括 RSS 和邮件订阅，但笔者认为这些方法都存在一定的局限性，尤其是邮件服务的费用和功能限制。通过 GitHub，读者只需点击链接即可订阅，之后笔者在该 Issue 下评论，订阅用户便会收到通知邮件。实现方式非常简单，只需在博客中添加一行链接代码，并确保锁定该 Issue 以避免其他评论。虽然这种方法依赖于 GitHub，无法统计订阅人数，但对于追求简约的用户来说，确实是个不错的选择。笔者也鼓励读者提供更好的解决方案，期待共同探讨。</p>\\n","date":{"time":1680264000000,"string":"2023/03/31","year":"2023年","monthDay":"03/31"},"tags":["订阅","GitHub","Issue","邮件","个人博客","订阅功能"]},{"title":"前端自给自足 UI 设计稿?(Midjourney+MasterGo)","url":"/posts/2023/03/29前端自给自足UI设计稿","excerpt":"<p>在这篇文章中，笔者分享了如何利用 Midjourney 与 MasterGo 这两款工具进行前端 UI 设计。过去，笔者在项目开发中常常缺乏统一的设计稿，导致页面风格不一，且修改成本高。为了改善这一点，笔者决定利用 Midjourney 生成 UI 设计稿。</p>\\n<p>首先，笔者介绍了如何通过 Midjourney 创建 UI 设计，包括使用简单的提示词生成高质量的设计图，并通过调整关键词来获取所需的多页面设计。接着，借助 MasterGo，笔者展示了如何根据生成的设计稿规范主题、设置模板以及绘制图形。通过这些步骤，笔者强调了工具的简单易用性，以及设计师审美能力的重要性。</p>\\n<p>最终，尽管笔者对自己的设计结果并不完全满意，仍然感到使用这些工具使得 UI 设计变得更加高效。</p>\\n","date":{"time":1680091200000,"string":"2023/03/29","year":"2023年","monthDay":"03/29"},"tags":["前端","UI 设计","Midjourney","MasterGo","工具"]},{"title":"聊聊前后端分离(历史、职责划分、未来发展)","url":"/posts/2023/03/22聊聊前后端分离(历史、职责划分、未来发展)","excerpt":"<p>笔者在这篇文章中深入探讨了前后端分离的历史、职责划分及未来发展。前后端分离的出现可以从业务和技术两个层面理解，随着互联网的普及和用户基数的增加，功能业务变得复杂，促使了这一模式的发展。文章梳理了前后端分离的五个重要阶段：传统 MVC 架构、Ajax 的出现、SPA 的普及、微服务架构和 BFF 模式，以及 Serverless 架构的兴起。</p>\\n<p>笔者强调，前后端的职责划分不仅仅是页面操作和数据库操作的区分，还包括如何在前端和后端之间有效分配业务处理和数据计算。笔者认为，尽量将可在前端处理的数据放在前端进行处理，以提高响应速度和降低服务器压力，但也指出了需放在后端处理的特定情况。最后，笔者鼓励前端工程师具备全栈思维，从全局出发思考前端问题，以更好适应未来的发展趋势。</p>\\n","date":{"time":1679486400000,"string":"2023/03/22","year":"2023年","monthDay":"03/22"},"tags":["前后端分离","全栈","互联网","SPA","微服务","BFF","Serverless"]},{"title":"三个经典的 TypeScript 易混淆点","url":"/posts/2023/03/06三个经典的TypeScript易混淆点","excerpt":"<p>笔者在本文中探讨了 TypeScript 中的三个经典易混淆点，这些问题不仅在开发中常见，也是面试官常考的内容。</p>\\n<ul>\\n<li>首先，笔者详细解析了<code>interface</code>与<code>type</code>的区别，强调在可用<code>interface</code>的情况下优先使用它，因为<code>interface</code>支持合并类型，而<code>type</code>则无法扩展。</li>\\n<li>接着，笔者介绍了<code>never</code>类型的定义与应用，指出它用于表示不会返回的函数，能帮助编译器进行类型检查，提升代码的安全性。</li>\\n<li>最后，笔者对<code>unknown</code>与<code>any</code>进行了比较，指出<code>unknown</code>是“顶级类型”，而<code>any</code>则放弃了类型检查，可能导致类型错误。</li>\\n</ul>\\n<p>通过这些分析，笔者希望帮助读者更好地理解 TypeScript 的高级用法。</p>\\n","date":{"time":1678104000000,"string":"2023/03/06","year":"2023年","monthDay":"03/06"},"tags":["TypeScript","interface","type","never","unknown","any"]},{"title":"你可能忽略的 10 种 JavaScript 快乐写法","url":"/posts/2023/02/23你可能忽略的10种JavaScript快乐写法","excerpt":"<p>笔者在这篇文章中探讨了十种可能被开发者忽视的 JavaScript 编程技巧，这些技巧不仅提升代码的简洁性与可读性，还能有效提高开发者的幸福感。</p>\\n<p>文章首先强调了代码美感的重要性，接着提供了实用的代码片段和技巧，涵盖了数组去重、获取数组最后一个元素、对象与数组之间的转换、短路操作、默认值赋值、多条件判断优化等多个方面。笔者还分享了位运算、交换值、<code>replace()</code>和<code>sort()</code>的回调用法等高级技巧，鼓励读者分享自己认为优秀的代码片段。这些技巧的掌握不仅能提升开发效率，也能让编程变得更加愉悦。</p>\\n<p>总之，笔者希望通过这篇文章帮助读者发现和应用这些 JavaScript 的“快乐写法”。</p>\\n","date":{"time":1677153600000,"string":"2023/02/23","year":"2023年","monthDay":"02/23"},"tags":["JavaScript","编程技巧","代码优化","代码简洁","代码美感"]},{"title":"放弃 Cookie-Session，拥抱 JWT？","url":"/posts/2023/02/19放弃Cookie-Session，拥抱JWT？","excerpt":"<p>笔者在这篇博客中深入探讨了 JWT（JSON Web Token）与传统的 Cookie-Session 的比较及其各自的优缺点。首先，JWT 是一种自包含令牌，用户信息存储在客户端，而 Cookie-Session 则是引用令牌，用户信息由服务器统一管理。通过一个简单的登录流程，笔者展示了 JWT 的基本使用方式，并阐述了它如何解决 Cookie-Session 的一些痛点，比如在分布式系统中的适用性。</p>\\n<p>尽管 JWT 在管理用户状态方面具有灵活性，但笔者也指出了其缺点，例如一旦令牌被发放，服务器对其控制能力下降，且在未使用 HTTPS 的情况下更易受到重放攻击。此外，笔者提到双 token 机制（access token 与 refresh token）的使用，以平衡安全性与用户体验。最终，笔者强调技术选择应基于项目需求，而非一味追求新技术，提醒读者 JWT 并不完全取代 Cookie-Session。</p>\\n","date":{"time":1676808000000,"string":"2023/02/19","year":"2023年","monthDay":"02/19"},"tags":["JWT","Cookie","Session","安全","分布式","HTTPS"]},{"title":"聊聊同源策略限制 AJAX 请求","url":"/posts/2023/02/17聊聊源策略限制AJAX请求","excerpt":"<p>在这篇博客中，笔者探讨了同源策略如何限制 AJAX 请求，并提出了一些深思的问题。首先，同源策略是浏览器的核心安全功能，主要限制了脚本对其他域的访问，包括 cookies、localStorage、DOM 和 AJAX 请求。笔者质疑，既然脚本无法访问跨域 cookies，是否可以放宽对 AJAX 请求的限制，从而简化跨域操作。通过研究，笔者发现虽然 cookies 不可跨域共享，但在同一浏览器的不同 Tab 中却是可见的，这使得 CSRF 攻击成为可能。</p>\\n<p>此外，笔者指出，AJAX 请求的限制是为了防止敏感数据泄露，比如 CSRF token。即使有 CSRF token 的防护，允许 AJAX 跨域请求仍可能导致安全隐患。最后，笔者强调，尽管 CSRF token 是有效防御手段，但同源策略依然需要限制 AJAX 请求，以增强安全性。整体而言，笔者希望通过这篇文章引发更多关于 Web 安全的讨论与思考。</p>\\n","date":{"time":1676635200000,"string":"2023/02/17","year":"2023年","monthDay":"02/17"},"tags":["同源策略","AJAX","Web 安全"]},{"title":"一文梳理 Vue3 核心原理","url":"/posts/2023/02/04Vue3相关原理梳理","excerpt":"<p>在这篇文章中，笔者深入探讨了 Vue3 的核心原理，旨在帮助开发者理解其背后的工作机制。</p>\\n<p>首先，笔者说明了使用 Vue 的原因，包括其高性能、组件化开发及活跃的社区支持等。接着，文章详细描述了 Vue 的编译过程，从编译源文件到生成虚拟 DOM，并强调了编译优化的重要性，如 Block 树、静态结点优化和内联事件优化。随后，笔者讲解了虚拟 DOM 的概念及 Patch 函数的实现，特别是 Diff 算法的细节，包括如何处理新旧节点的比较和移动策略。最后，笔者概述了响应式系统的工作流程，强调了依赖收集和触发机制，并提到 Vue3 在模板根节点支持多结点的进步。</p>\\n<p>整篇文章不仅梳理了 Vue3 的原理，还为进一步学习提供了丰富的参考资源。</p>\\n","date":{"time":1675512000000,"string":"2023/02/04","year":"2023年","monthDay":"02/04"},"tags":["Vue3","前端","虚拟 DOM","响应式","Diff 算法","编译优化","依赖收集"]},{"title":"TypeScript 入门","url":"/posts/2022/02/02TypeScript入门","excerpt":"<p>笔者在这篇文章中详细介绍了 TypeScript 的基础知识及其使用方法，帮助初学者跨出学习的第一步。首先，笔者指导读者如何安装 TypeScript，并编写和编译简单的“Hello World”程序，强调 TypeScript 是 JavaScript 的超集，解决了 JavaScript 动态类型带来的问题。接着，笔者展示了如何通过<code>tsconfig.json</code>配置文件批量编译多个 TypeScript 文件，提升开发效率。</p>\\n<p>接下来的部分深入探讨了 TypeScript 的类型系统，包括基本类型、对象类型、数组、元组和枚举等，强调类型安全的重要性。笔者还介绍了类的概念，包括构造函数、继承、抽象类和接口，展示了如何利用 TypeScript 的特性提高代码的可读性和可维护性。最后，笔者提到泛型的使用，进一步提升了代码的灵活性。整篇文章旨在让读者快速上手 TypeScript，并为后续学习打下坚实基础。</p>\\n","date":{"time":1675339200000,"string":"2023/02/02","year":"2023年","monthDay":"02/02"},"tags":["TypeScript","JavaScript","编程","前端","类型"]},{"title":"了解 API 相关范式(RPC、REST、GraphQL)","url":"/posts/2023/01/28了解API相关范式(RPC、REST、GraphQL)","excerpt":"<p>笔者在本文中探讨了三种常见的 API 范式：RPC、REST 和 GraphQL。</p>\\n<ul>\\n<li>RPC 允许开发者像调用本地方法一样调用远程方法，具有高效低延迟的优点，但与底层系统紧密耦合，降低了可重用性。</li>\\n<li>REST 则是一种面向资源的风格，强调客户端与服务器的解耦，支持多种数据格式，便于缓存，但在实践中缺乏统一结构，可能导致高负载和数据过度获取。</li>\\n<li>GraphQL 作为一种查询语言，允许客户端灵活请求所需数据，减少了请求次数，但存在性能问题和学习成本。</li>\\n</ul>\\n<p>总体而言，RPC 适合内部微服务，REST 适用于标准 API 建模，而 GraphQL 在数据获取的灵活性上占优势，开发者应根据具体需求选择合适的 API 范式。</p>\\n","date":{"time":1674907200000,"string":"2023/01/28","year":"2023年","monthDay":"01/28"},"tags":["API","RPC","REST","GraphQL","Web"]},{"title":"浅谈 NestJS 设计思想（分层、IOC、AOP","url":"/posts/2023/01/25浅谈NestJS设计思想","excerpt":"<p>笔者在这篇文章中深入探讨了 NestJS 框架的设计思想，重点分析了分层架构、控制反转（IoC）和面向切面编程（AOP）。</p>\\n<p>首先，分层架构使得不同层次的逻辑清晰可分，便于维护和扩展，强调了 Service 层的必要性，以提高代码的复用性和模块化。其次，IoC 通过依赖注入的方式减少了类之间的紧耦合，使得系统更具灵活性，便于未来的修改和扩展。最后，AOP 通过在请求处理链中引入切面，简化了通用逻辑的管理，如日志记录和权限验证等。</p>\\n<p>这些设计思想相辅相成，提升了 NestJS 的可维护性和可扩展性，值得开发者在实际项目中深入理解和应用。</p>\\n","date":{"time":1674648000000,"string":"2023/01/25","year":"2023年","monthDay":"01/25"},"tags":["NestJS","设计模式","分层","IOC","AOP"]},{"title":"JavaScript 专题-继承","url":"/posts/2023/01/08JavaScript专题-继承","excerpt":"<p>在这篇关于 JavaScript 继承的文章中，笔者详细探讨了不同的继承实现方式及其优缺点。</p>\\n<p>首先，介绍了原型链继承的基本思想，指出其在共享引用值时的缺陷。接着，讨论了盗用构造函数的实现，这种方式避免了共享属性，但导致方法不能重用。随后，笔者结合两者优点提出组合式继承，虽然实现了属性和方法的灵活共享，但仍然调用了两次父类构造函数。接下来介绍了原型式继承和寄生式继承，它们各自的优缺点也被一一列举。最后，笔者提出了寄生式组合继承的解决方案，通过创建父类原型的副本，避免了不必要的构造函数调用，从而提升了效率。</p>\\n<p>整个文章旨在帮助读者深入理解 JavaScript 继承的复杂性与灵活性。</p>\\n","date":{"time":1673179200000,"string":"2023/01/08","year":"2023年","monthDay":"01/08"},"tags":["JavaScript","继承","原型链","盗用构造函数","组合式继承","原型式继承","寄生式继承","寄生组合式继承"]},{"title":"JavaScript 专题-原型链","url":"/posts/2023/01/02JavaScript专题-原型链","excerpt":"<p>在这篇文章中，笔者深入探讨了 JavaScript 中的原型链及其相关概念。首先，原型（<code>prototype</code>）被定义为每个构造函数的内置属性，允许实例共享属性和方法。通过示例，笔者展示了如何创建构造函数及其原型对象，并解释了实例如何通过内部指针<code>[[Prototype]]</code>访问原型上的属性和方法。接着，笔者详细描述了原型链的概念，强调每个对象都有指向其原型的指针，形成层级关系。</p>\\n<p>值得注意的是，原型对象中的<code>constructor</code>属性并不总是可靠的类型判断工具，因为其可能被覆盖。文章最后，笔者提供了一些参考资料，鼓励读者深入理解原型和原型链的机制。这一系列内容不仅加深了对 JavaScript 的理解，也为更复杂的概念打下了基础。</p>\\n","date":{"time":1672660800000,"string":"2023/01/02","year":"2023年","monthDay":"01/02"},"tags":["JavaScript","原型链","原型","原型继承","原型链继承"]},{"title":"获取 Object 的第一个元素","url":"/posts/2022/10/16获取Object的第一个元素","excerpt":"<p>在这篇文章中，笔者探讨了如何从一个 JavaScript 对象中获取第一个元素。由于对象的属性是无序的，笔者指出，使用<code>Object.keys</code>和<code>for in</code>方法时，迭代的顺序并不总是符合预期。为了解释这一点，笔者总结了对象属性迭代的规律：</p>\\n<ol>\\n<li>数字或字符串形式的数字作为键时，按升序排序。</li>\\n<li>普通字符串类型的键按定义顺序输出。</li>\\n<li>Symbols 与字符串类型的规则相同。</li>\\n<li>如果存在三种类型的键，优先顺序为数字键 -&gt; 字符串键 -&gt; Symbol 键。</li>\\n</ol>\\n<p>根据这些规则，笔者提出可以通过解构赋值的方式优雅地获取对象的第一个元素，从而满足实际业务需求。最后，文章附上了相关的参考链接，供读者深入了解对象属性的迭代顺序。</p>\\n","date":{"time":1665921600000,"string":"2022/10/16","year":"2022年","monthDay":"10/16"},"tags":["JavaScript","Object","解构","ES6"]},{"title":"JavaScript 基础-replace 方法的第二个参数","url":"/posts/2022/10/15JavaScript基础-replace方法的第二个参数","excerpt":"<p>笔者在重新阅读《JavaScript 高级程序设计》第四版时，对<code>replace</code>方法的第二个参数有了更深的理解。</p>\\n<p>该方法的第一个参数可以是字符串或正则表达式，而第二个参数则可以是字符串或回调函数。作为字符串时，第二个参数可以使用以<code>$</code>符号开头的特殊字符进行更复杂的替换，例如<code>$&amp;</code>用于重复匹配的字符，<code>$\'</code>和<code>$\'</code>用于获取匹配字符串的前后部分，<code>$n</code>用于交换匹配组。</p>\\n<p>更进一步，回调函数的使用使得自定义替换变得灵活，通过传入函数，可以根据需要动态生成替换内容，笔者举了实现模板字符串的例子，展示了如何将模板中的变量替换为实际值。这种灵活性使得<code>replace</code>方法在字符串处理上非常强大与实用。</p>\\n","date":{"time":1665835200000,"string":"2022/10/15","year":"2022年","monthDay":"10/15"},"tags":["JavaScript","replace","字符串"]},{"title":"超详细的前端程序员 git 指北","url":"/posts/2022/10/14超详细的前端程序员git指北","excerpt":"<p>笔者在这篇博客中深入探讨了如何高效使用 Git 进行团队开发，特别是从创建分支到合并代码的整个流程。</p>\\n<p>首先，笔者强调了 Git 在团队开发中的重要性，并通过一个示例演示了从创建仓库、分支管理到合并请求的具体步骤。接下来，笔者详细介绍了如何创建功能分支、提交代码、合并多个提交以及解决合并冲突的技巧。特别是在处理合并请求时，如何使用<code>rebase</code>来同步最新代码并解决冲突是一个重点。最后，笔者还概述了<code>reset</code>与<code>revert</code>命令的不同，以及如何使用<code>cherry-pick</code>选择性地合并提交。</p>\\n<p>整篇文章以实用为导向，旨在帮助开发者掌握 Git 的核心使用技巧，提升团队协作的效率。</p>\\n","date":{"time":1665748800000,"string":"2022/10/14","year":"2022年","monthDay":"10/14"},"tags":["Git","团队开发","分支管理","rebase","reset","revert","cherry-pick"]},{"title":"CDN 实践配置+原理篇","url":"/posts/2022/10/13CDN实践配置+原理篇","excerpt":"<p>笔者在这篇文章中详细讲解了 CDN（内容分发网络）的基本概念、作用及其在阿里云对象存储中的配置过程。</p>\\n<p>CDN 通过将用户请求路由到最近的服务器，显著提高了内容加载速度并减轻了源服务器的负担。此外，CDN 还增强了安全性，能够有效防御 DDoS 和 MITM 等网络攻击。文章中提供了具体的配置步骤，包括如何将加速域名指向 CNAME 地址，以及如何映射自定义域名。通过对比不同的 OSS 配置方案，笔者指出方案四结合了 CDN 的优势与自定义域名的便捷性。在总结 CDN 的工作原理时，笔者清晰地描述了用户请求的整个过程，强调了 DNS 解析在 CDN 加速中的重要性。</p>\\n<p>整体而言，本文为 CDN 的应用提供了实用的指导。</p>\\n","date":{"time":1665662400000,"string":"2022/10/13","year":"2022年","monthDay":"10/13"},"tags":["CDN","阿里云","对象存储","域名解析","DNS","HTTPS"]},{"title":"Node 进程及集群相关","url":"/posts/2022/06/12Node进程及集群相关","excerpt":"<p>笔者在这篇文章中深入探讨了 Node.js 中的进程及集群相关概念，首先介绍了 Node.js 的多进程创建方法，包括<code>spawn()</code>、<code>exec()</code>、<code>execFile()</code>和<code>fork()</code>，并详细阐述了它们的区别和适用场景。接着，笔者分析了 Node.js 的多进程架构，强调主进程与工作进程的角色分配，以及如何利用多核 CPU 的优势。</p>\\n<p>此外，文章还介绍了进程间通信的原理，尤其是通过 IPC 通道传递消息的机制。笔者提到，Node.js 支持多个进程监听相同端口的能力，使用<code>send()</code>方法直接转发 socket 句柄，从而避免了传统代理模式的缺陷。</p>\\n<p>最后，笔者讨论了集群的稳定性和负载均衡策略，包括平滑重启和重启频率控制，并对 Node.js 的<code>cluster</code>模块进行了简要介绍，指出其在多核 CPU 利用率和进程管理上的优势。</p>\\n","date":{"time":1655035200000,"string":"2022/06/12","year":"2022年","monthDay":"06/12"},"tags":["Node.js","进程","集群","IPC","cluster"]},{"title":"Node 内存控制","url":"/posts/2022/06/11Node内存控制","excerpt":"<p>在重新阅读《深入浅出 NodeJS》的过程中，我深入了解了 Node.js 的内存控制机制。Node.js 基于 V8 引擎，其内存使用受到限制，64 位系统约为 1.4GB，32 位系统约为 0.7GB，尽管物理内存可能更大。这是由于 V8 的垃圾回收机制设计，旨在优化性能，避免长时间的停顿。</p>\\n<p>我学习了 V8 的内存管理是通过分代垃圾回收机制进行的，包括新生代和老生代两部分。新生代使用 Scavenge 算法，快速回收短生命周期对象；老生代则结合 Mark-Sweep 和 Mark-Compact 算法，清理长生命周期对象。全停顿问题促使了增量标记等优化策略的出现，进一步提高了应用的响应能力。此外，内存泄漏的常见原因包括缓存未过期、队列消费不及时及作用域未释放，理解这些有助于我在实际开发中更好地监控和管理内存。</p>\\n","date":{"time":1654948800000,"string":"2022/06/11","year":"2022年","monthDay":"06/11"},"tags":["Node.js","V8","内存","垃圾回收","内存泄漏","深入浅出 NodeJS"]},{"title":"Node 异步实现与事件驱动","url":"/posts/2022/06/10Node异步实现与事件驱动","excerpt":"<p>在重新阅读《深入浅出 NodeJS》的过程中，我深入理解了 Node 的异步实现与事件驱动特性。Node 通过单线程结合异步 I/O，避免了多线程带来的复杂性和性能开销。它利用非阻塞 I/O 与事件循环机制，允许 CPU 在等待 I/O 操作时处理其他任务，从而提高了资源利用率。</p>\\n<p>我学习了阻塞与非阻塞 I/O 的区别，以及不同轮询方法（如<code>select</code>、<code>poll</code>、<code>epoll</code>等）的优缺点。Node 内部虽是多线程处理 I/O，但开发者的 JavaScript 代码仍在单线程中运行。此外，<code>setTimeout</code>、<code>setImmediate</code>和<code>process.nextTick</code>等 API 的实现原理与异步 I/O 相似，但不需要线程池的介入。</p>\\n<p>通过事件驱动模型，Node 能够高效地处理网络请求，解决了如雪崩问题等性能挑战。这一切都让我对 Node 的异步处理有了更深的理解。</p>\\n","date":{"time":1654862400000,"string":"2022/06/10","year":"2022年","monthDay":"06/10"},"tags":["Node.js","异步","事件驱动"]},{"title":"Node 模块规范及模块加载机制","url":"/posts/2022/06/09Node模块规范及模块加载机制","excerpt":"<p>笔者在重新阅读《深入浅出 NodeJS》时，对 Node 的模块规范和加载机制有了更深的理解。首先，Node 采用了 CommonJS 规范来解决 JavaScript 早期缺乏模块机制的问题。CommonJS 的核心在于模块引用、定义和标识，通过<code>require</code>和<code>exports</code>实现模块的引入和导出。每个模块在 Node 中被封装在一个函数中，使用<code>module</code>、<code>exports</code>和<code>require</code>等参数实现作用域隔离。</p>\\n<p>在模块加载过程中，Node 通过路径分析、文件定位和编译执行的步骤来处理模块。核心模块的加载速度更快，因为它们在 Node 编译时就已存在内存中。笔者还提到，Node 的模块机制不仅能避免变量污染，还能通过模块引用图分析项目结构，提升开发效率。阅读过程中，笔者意识到掌握这些基础知识对未来的求职面试至关重要。</p>\\n","date":{"time":1654776000000,"string":"2022/06/09","year":"2022年","monthDay":"06/09"},"tags":["Node.js","模块规范","模块加载机制"]},{"title":"前端工程化的学习(偏向 vite 构建工具)","url":"/posts/2022/06/08前端构建的学习(偏向vite)","excerpt":"<p>笔者在学习前端工程化时，决定深入了解 Vite 构建工具，尤其是在项目中需要封装组件的过程中，感受到脚手架的缺乏带来的不便。Vite 的优势在于其开发环境中基于 ES 模块的按需加载，极大提升了启动速度，尤其在处理大型项目时表现出色。与 Webpack 相比，Vite 更关注开发体验，而 Webpack 则强调兼容性。</p>\\n<p>笔者总结了 Vite 的几个重要特性，如依赖预构建、路径补全、以及对 CSS 和静态资源的处理方式。同时，笔者提到构建优化的重要性，包括体积优化和分包策略，以提高浏览器的缓存效率。整体而言，Vite 的设计理念使得前端开发更为高效，帮助开发者更专注于代码编写而非运行细节。</p>\\n","date":{"time":1654689600000,"string":"2022/06/08","year":"2022年","monthDay":"06/08"},"tags":["前端","工程化","vite"]},{"title":"IntersectionObserver 实现横竖滚动自适应懒加载","url":"/posts/2022/05/07IntersectionObserver实现横竖滚动自适应懒加载","excerpt":"<p>在这篇文章中，笔者分享了如何使用<code>IntersectionObserver</code>实现横竖滚动的懒加载功能，特别是在使用<code>vitepress</code>编写个人网站时遇到的需求。由于组件中可能存放大量图片，懒加载显得尤为重要。<code>IntersectionObserver</code> API 允许我们监测元素与视窗的交叉状态，从而决定何时加载该元素。</p>\\n<p>文章详细介绍了<code>IntersectionObserver</code>的构造方法及其方法，包括<code>observe</code>、<code>unobserve</code>等。笔者的思路是，首先观察容器的可见性，如果容器可见，则开始观察其中图片的可见性，这样便实现了竖向懒加载和横向懒加载的结合。通过示例代码，笔者展示了如何在<code>onMounted</code>生命周期钩子中设置这些观察器，并在图片进入视口时加载它们，最终实现了流畅的懒加载效果。</p>\\n","date":{"time":1651924800000,"string":"2022/05/07","year":"2022年","monthDay":"05/07"},"tags":["IntersectionObserver","懒加载","横竖滚动","自适应"]},{"title":"玩转 vitepress","url":"/posts/2022/05/06玩转vitepress","excerpt":"<p>笔者在文章中分享了使用<code>vitepress</code>搭建个人网站的经历和技巧。最初在<code>0.22.x</code>版本时，笔者遇到了一些功能缺失的问题，但在发现<code>vitepress</code>正式版本发布后，兴奋地进行了升级，解决了之前的不满。</p>\\n<p>文章详细介绍了从<code>0.xx</code>版本迁移的步骤，以及如何快速启动站点。笔者强调了<code>markdown</code>文件与<code>HTML</code>文件的对应关系，并指出了避免死链接的重要性。此外，笔者分享了如何自定义站点的导航、侧边栏和主页布局，提供了相应的代码示例和配置选项。最后，笔者提到可以使用<code>vue</code>组件并介绍了自己开发的<code>many-pictures</code>组件及<code>gitalk</code>评论系统的集成，鼓励读者访问自己的个人博客以获取更多内容。</p>\\n","date":{"time":1651838400000,"string":"2022/05/06","year":"2022年","monthDay":"05/06"},"tags":["vitepress","vue","markdown","gitalk"]},{"title":"前端程序员搭建自己的 CodeIDE（code-server 教程）","url":"/posts/2022/05/05前端程序员搭建自己的CodeIDE（code-server教程）","excerpt":"<p>笔者在这篇文章中详细介绍了如何在 Ubuntu 20 上搭建自己的 CodeIDE，使用 code-server 实现浏览器编程的便利。首先，通过官方链接下载 code-server，并在服务器上解压后即可运行。设置时需要注意<code>--port</code>和<code>--host</code>参数，以便允许远程访问。接着，笔者建议配置<code>config.yaml</code>文件以实现 HTTPS 访问，并提供了获取证书的方式。</p>\\n<p>为了管理代码服务器进程，笔者使用了 pm2 工具，同时也提到了解析域名的操作。此外，还分享了如何配置 VS Code 的插件和设置同步，甚至介绍了如何安装 JavaScript 版本的 Jupyter（ijavascript），以便在 Jupyter Notebook 中使用 JavaScript。最后，笔者提供了详细的视频教程，方便读者更直观地了解整个搭建过程。</p>\\n","date":{"time":1651752000000,"string":"2022/05/05","year":"2022年","monthDay":"05/05"},"tags":["CodeIDE","code-server","前端","编程"]},{"title":"git 常用操作","url":"/posts/2022/02/04git常用操作","excerpt":"<p>在这篇文章中，笔者总结了几种常用的 Git 操作，特别是在分支管理和提交合并方面的技巧。</p>\\n<p>首先，提到使用 <code>git rebase</code> 进行分支同步和合并多个提交，这种方式能有效减少冲突并保持提交历史的整洁。其次，介绍了 <code>git cherry-pick</code> 的使用，它允许从一个分支挑选特定的提交合并到另一个分支，避免了不必要的合并分叉。此外，笔者强调了 <code>git reset</code> 和 <code>git revert</code> 的区别，前者是直接回退到某个提交，而后者则是通过新增一个反向提交来恢复状态，确保安全性。最后，笔者提到使用标签（tag）来管理版本，方便在生产环境中进行版本控制和回退。这些操作和策略为开发者提供了灵活的版本管理方式。</p>\\n","date":{"time":1643976000000,"string":"2022/02/04","year":"2022年","monthDay":"02/04"},"tags":["Git","团队开发","分支管理","rebase","reset","revert","cherry-pick"]},{"title":"这道题原来可以用到 JS 这么多知识点！","url":"/posts/2022/02/03这道题原来可以用到JS这么多知识点！","excerpt":"<p>在这篇文章中，笔者探讨了如何解决“二叉树中和为某一值的路径”这一问题。题目要求从二叉树的根节点到叶子节点的路径，其节点值之和需等于给定的 <code>expectNumber</code>。为了解决此题，笔者采用了深度优先遍历(DFS)的策略，利用递归来遍历树的每一条路径。</p>\\n<p>笔者特别强调了两种变量的区别：值变量 <code>cur</code> 和引用变量 <code>arr</code>。<code>cur</code> 用于存储当前的累加和，而 <code>arr</code> 则用于存储当前路径。为了避免在递归中对 <code>arr</code> 的修改影响到外部作用域，笔者使用了 ES6 的扩展运算符来复制数组。最终，笔者给出了清晰的代码实现，并附上了注释，确保读者能够理解每一步的逻辑和实现细节。</p>\\n","date":{"time":1643889600000,"string":"2022/02/03","year":"2022年","monthDay":"02/03"},"tags":["JavaScript","算法","二叉树","递归","DFS"]},{"title":"2022 年了，还是得学圣杯布局与双飞翼布局","url":"/posts/2022/02/01都2022年了，还是得学圣杯布局与双飞翼布局","excerpt":"<p>笔者在这篇文章中探讨了三列布局的多种实现方式，包括绝对定位、flex 布局和浮动布局，每种方法都有其优缺点。特别强调了圣杯布局和双飞翼布局，前者通过浮动和负边距的组合，能够将中间列的内容放在最前面，提升页面加载体验。实现圣杯布局时，首先设置 BFC 父容器的左右 padding 来为两侧栏预留空间，接着通过负 margin 和相对定位调整左右栏位置。而双飞翼布局则采用中间列的 margin 来实现左右栏的保留，简化了父容器的设置。总体而言，这些布局技巧为网页设计提供了灵活的解决方案，尤其在处理响应式设计时的应用。</p>\\n","date":{"time":1643716800000,"string":"2022/02/01","year":"2022年","monthDay":"02/01"},"tags":["布局","圣杯布局","双飞翼布局","响应式设计","flex 布局","浮动布局"]},{"title":"散列表实现查找","url":"/posts/2021/08/04散列表实现查找","excerpt":"<p>作为一名技术专家，我深入探讨了散列表的实现及其查找过程。文章首先通过 Python 代码从 Excel 文件中读取数据，并去除缺失值，最终得到 75 条企业信息。接着，我实现了两个主要的哈希方法：<strong>平方取中法</strong>和<strong>除留余数法</strong>，并分别应用开放地址法和公共溢出法解决冲突。</p>\\n<p>在查找过程中，用户可以选择根据电话号码或企业名称进行搜索。通过对比两种查找方法的平均查找长度（ASL），结果显示开放地址法的效率明显优于公共溢出法，且平方取中法与除留余数法在地址映射的重复性方面表现相似。最终得出的结果表明，数据重复度越高，查找效率越低，开放地址法在存储空间和查找效率之间达成了一种平衡。</p>\\n","date":{"time":1628078400000,"string":"2021/08/04","year":"2021年","monthDay":"08/04"},"tags":["Python","数据结构","散列表","查找","哈希","开放地址法","公共溢出法","平方取中法","除留余数法"]},{"title":"操作系统内存分配模拟程序","url":"/posts/2021/08/03操作系统内存分配模拟程序","excerpt":"<p>笔者在这篇博客中实现了一个操作系统内存分配的模拟程序，主要包含内存管理的基本操作和多种分配算法。首先，程序设置了内存的最大容量，并定义了空闲和已分配内存的表格。接着，作者实现了三个主要的内存分配算法：首次适应算法、循环首次适应算法和最佳/最差动态分区分配算法。这些算法通过遍历空闲内存表，寻找合适的内存块进行分配，并在进程完成后回收内存，合并相邻的空闲块以提高内存利用率。</p>\\n<p>在测试部分，笔者通过一系列分配任务演示了内存分配的过程，并展示了不同算法在内存分配中的效果。最终，程序不仅展示了内存的实时状态，还有效地模拟了操作系统在实际运行中的内存管理策略。</p>\\n","date":{"time":1627992000000,"string":"2021/08/03","year":"2021年","monthDay":"08/03"},"tags":["操作系统","内存分配","模拟程序","首次适应算法","循环首次适应算法","最佳动态分区分配","最差动态分区分配"]},{"title":"TFIDF 计算的学习","url":"/posts/2021/04/02TFIDF计算的学习","excerpt":"<p>笔者在这篇博客中详细介绍了 TF-IDF（Term Frequency-Inverse Document Frequency）的计算过程，首先通过转码函数确保文本文件的编码为 UTF-8，并读取文件列表。接着，使用正则表达式对文本进行分词，从而建立词典并计算每个词的词频（TF）。随后，笔者构建了 TF 矩阵，并逐步计算每个词的逆文档频率（IDF），最终合并 TF 和 IDF 值以得到 TF-IDF 值。</p>\\n<p>此外，笔者也展示了使用 Sklearn 库来简化 TF-IDF 的计算过程，并介绍了如何计算文档之间的余弦相似度，以评估它们的相似性。整个过程通过代码示例和数据框展示，使得读者能够直观理解 TF-IDF 的实现细节及其应用。</p>\\n","date":{"time":1617364800000,"string":"2021/04/02","year":"2021年","monthDay":"04/02"},"tags":["TFIDF","文本挖掘","机器学习","自然语言处理","Python","Sklearn","余弦相似度"]},{"title":"scrapy 爬虫详解","url":"/posts/2021/04/01scrapy爬虫详解","excerpt":"<p>笔者在这篇博客中详细介绍了 Scrapy 爬虫的基本原理及其运行过程。首先，笔者阐述了爬虫的基本工作流程，包括身份验证、数据请求、数据解析及保存数据的步骤。接着，笔者重点讲解了 Scrapy 框架的 5+2 结构组件，包括引擎、调度器、下载器、数据管道、爬虫、中间件等，强调了各组件的功能及其在爬虫工作中的重要性。通过图示，笔者进一步解释了数据从请求到保存的整个流程，让读者对 Scrapy 的操作有了更深的理解。此外，笔者还提供了安装 Scrapy 及创建项目的实战指导，鼓励小白用户勇于尝试，最终通过实例和源码链接引导读者深入学习。</p>\\n","date":{"time":1617278400000,"string":"2021/04/01","year":"2021年","monthDay":"04/01"},"tags":["爬虫","scrapy","数据爬取"]},{"title":"使用 anaconda 中的 Prompt 配置虚拟环境的常用命令","url":"/posts/2020/06/02使用anaconda中的Prompt配置虚拟环境的常用命令","excerpt":"<p>笔者在这篇文章中总结了 Anaconda 中使用命令行配置虚拟环境的常用命令，以便于自己和他人在需要时快速查阅。首先，文章强调了换源的重要性，提供了查看和更改源的命令，以及国内常用镜像源的链接，如清华大学、阿里云等。此外，笔者还介绍了如何创建和激活虚拟环境的步骤，并提供了安装特定包及查看已安装包的命令。具体命令包括：</p>\\n<ul>\\n<li>查看源：<code>conda config --show-sources</code></li>\\n<li>创建虚拟环境：<code>conda create -n python37 python=3.7</code></li>\\n<li>激活虚拟环境：<code>conda activate (你的环境名)</code></li>\\n<li>查看虚拟环境列表：<code>conda env list</code></li>\\n<li>查看当前环境中的包：<code>conda list</code></li>\\n</ul>\\n<p>这份总结为用户提供了便利，避免了每次都要搜索的麻烦。</p>\\n","date":{"time":1591099200000,"string":"2020/06/02","year":"2020年","monthDay":"06/02"},"tags":["anaconda","conda","虚拟环境","命令行"]},{"title":"Java 迷宫","url":"/posts/2020/06/01Java迷宫","excerpt":"<p>笔者在这篇博客中分享了一个 Java 迷宫的课程设计，详细介绍了迷宫的生成及路径寻找算法。迷宫的生成采用了递归分割法和递归回溯法，前者通过在一个被墙壁围住的区域内随机打通墙壁，形成通路；后者则通过从起点出发，随机选择方向并回退，直到所有可能路径都被探索。路径寻找方面，笔者实现了广度优先算法和深度优先算法，前者确保找到最短路径，而后者则提供了一条可行路径。</p>\\n<p>此外，笔者还提供了相关的 Java 代码，涵盖了迷宫的生成和路径寻找的实现。通过这些代码，读者可以更好地理解和实现迷宫的相关算法，提升编程能力。整体而言，这篇文章不仅帮助读者掌握了迷宫算法，还展示了笔者在算法实现方面的深入思考。</p>\\n","date":{"time":1591012800000,"string":"2020/06/01","year":"2020年","monthDay":"06/01"},"tags":["Java","算法","迷宫","课程设计"]}]');export{e as d};
