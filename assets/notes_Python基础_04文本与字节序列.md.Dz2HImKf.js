import{_ as s,D as i,B as a,ah as n}from"./chunks/framework.kYnPRA0Y.js";const y=JSON.parse('{"title":"文本与字节序列","description":"","frontmatter":{},"headers":[],"relativePath":"notes/Python基础/04文本与字节序列.md","filePath":"notes/Python基础/04文本与字节序列.md","lastUpdated":1738344267000}'),t={name:"notes/Python基础/04文本与字节序列.md"},e=n(`<h1 id="文本与字节序列" tabindex="-1">文本与字节序列 <a class="header-anchor" href="#文本与字节序列" aria-label="Permalink to &quot;文本与字节序列&quot;">​</a></h1><blockquote><p>此笔记记录于《流畅的 python》，大部分为其中的摘要，少部分为笔者自己的理解；笔记为 jupyter 转的 markdown，原始版 jupyter 笔记在<a href="https://github.com/Justin3go/fluent-python-note" target="_blank" rel="noreferrer">这个仓库</a></p></blockquote><h2 id="字符问题" tabindex="-1">字符问题 <a class="header-anchor" href="#字符问题" aria-label="Permalink to &quot;字符问题&quot;">​</a></h2><p>Unicode 标准把字符的标识和具体的字节表述进行了如下的明确区分：</p><ul><li>字符的标识，即码位，是<code>0~1114111</code>的数字（十进制），在 Unicode 标准中以<code>4~6</code>个十六进制数字表示，而且加前缀<code>“U+”</code>。例如，字母 A 的码位是<code>U+0041</code>，欧元符号的码位是<code>U+20AC</code>，高音谱号的码位是<code>U+1D11E</code>。在<code>Unicode 6.3</code>中（这是<code>Python 3.4</code>使用的标准），约 10%的有效码位有对应的字符。</li><li>字符的具体表述取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。在<code>UTF-8</code>编码中，<code>A（U+0041）</code>的码位编码成单个字节<code>\\x41</code>，而在<code>UTF-16LE</code>编码中编码成两个字节<code>\\x41\\x00</code>。再举个例子，欧元符号<code>（U+20AC）</code>在<code>UTF-8</code>编码中是三个字节——<code>\\xe2\\x82\\xac</code>，而在<code>UTF-16LE</code>中编码成两个字节：<code>\\xac\\x20</code>。</li></ul><blockquote><p>一些面试八股文就会问到 Unicode 与 utf-8 之间的关系</p></blockquote><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;café&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 这里有 4 个 Unicode 字符</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 4</span></span></code></pre></div><pre><code>4
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.encode(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 UTF-8 把 str 编码成 bytes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span></span></code></pre></div><pre><code>b&#39;caf\\xc3\\xa9&#39;
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字节序列 b 有 5 个字节（在 UTF-8 中，“é”的码位编码成两个字节）</span></span></code></pre></div><pre><code>5
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.decode(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 用 UTF-8 解码成 str</span></span></code></pre></div><pre><code>&#39;café&#39;
</code></pre><p>可以把字节序列想成晦涩难懂的机器磁芯转储，把 Unicode 字符串想成“人类可读”的文本。</p><h2 id="字节概要" tabindex="-1">字节概要 <a class="header-anchor" href="#字节概要" aria-label="Permalink to &quot;字节概要&quot;">​</a></h2><p>Python 内置了两种基本的二进制序列类型：Python 3 引入的不可变 bytes 类型和 Python 2.6 添加的可变 bytearray 类型。（Python 2.6 也引入了 bytes 类型，但那只不过是 str 类型的别名，与 Python 3 的 bytes 类型不同。）</p><p>bytes 或 bytearray 对象的各个元素是介于 0~255（含）之间的整数，而不像 Python 2 的 str 对象那样是单个的字符。二进制序列的切片始终是同一类型的二进制序列，包括长度为 1 的切片</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;café&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">encoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf_8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe</span></span></code></pre></div><pre><code>b&#39;caf\\xc3\\xa9&#39;
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 99</span></span></code></pre></div><pre><code>99
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe[:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># b&#39;c&#39;</span></span></code></pre></div><pre><code>b&#39;c&#39;
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe_arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bytearray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cafe)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe_arr</span></span></code></pre></div><pre><code>bytearray(b&#39;caf\\xc3\\xa9&#39;)
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cafe_arr[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># bytearray(b&#39;é&#39;)</span></span></code></pre></div><pre><code>bytearray(b&#39;\\xa9&#39;)
</code></pre><p><strong><code>my_bytes[0]</code>获取的是一个整数，而<code>my_bytes[:1]</code>返回的是一个长度为 1 的 bytes 对象——这一点应该不会让人意外。<code>s[0]==s[:1]</code>只对 str 这个序列类型成立。</strong></p><p>虽然二进制序列其实是整数序列，但是它们的字面量表示法表明其中有 ASCII 文本。因此，各个字节的值可能会使用下列三种不同的方式显示。</p><ul><li>可打印的 ASCII 范围内的字节（从空格到~），使用 ASCII 字符本身。</li><li>制表符、换行符、回车符和\\对应的字节，使用转义序列\\t、\\n、\\r 和\\。</li><li>其他字节的值，使用十六进制转义序列（例如，\\x00 是空字节）。</li></ul><p>我们看到的是<code>b&#39;caf\\xc3\\xa9&#39;</code>：前 3 个字节<code>b&#39;caf&#39;</code>在可打印的 ASCII 范围内，后两个字节则不然。</p><p>除了格式化方法（format 和 format_map）和几个处理 Unicode 数据的方法（包括 casefold、isdecimal、isidentifier、isnumeric、isprintable 和 encode）之外，str 类型的其他方法都支持 bytes 和 bytearray 类型</p><p>除了格式化方法（format 和 format_map）和几个处理 Unicode 数据的方法（包括 casefold、isdecimal、isidentifier、isnumeric、isprintable 和 encode）之外，str 类型的其他方法都支持 bytes 和 bytearray 类型</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.fromhex(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;31 4B CE A9&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># b&#39;1KÎ©&#39;</span></span></code></pre></div><pre><code>b&#39;1K\\xce\\xa9&#39;
</code></pre><p>使用缓冲类对象创建 bytes 或 bytearray 对象时，始终复制源对象中的字节序列。与之相反，memoryview 对象允许在二进制数据结构之间共享内存。</p><p><strong>结构体和内存视图</strong>：</p><p>struct 模块提供了一些函数，把打包的字节序列转换成不同类型字段组成的元组，还有一些函数用于执行反向转换，把元组转换成打包的字节序列。struct 模块能处理 bytes、bytearray 和 memoryview 对象。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 memoryview 和 struct 查看一个 GIF 图像的首部</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> struct</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fmt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&lt;3s3sHH&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 结构体的格式：&lt;表示小字节序，3s3s 是两个 3 字节序列，HH 是两个 16 位二进制整数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filter.gif&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;rb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fp:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> memoryview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fp.read())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">header </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> img[:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(header) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># b&#39;GIF89a+\\x02\\x0f\\x00&#39;</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">struct.unpack(fmt, header) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (b&#39;GIF&#39;, b&#39;89a&#39;, 555, 15)</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> img</span></span></code></pre></div><h2 id="基本的编解码器" tabindex="-1">基本的编解码器 <a class="header-anchor" href="#基本的编解码器" aria-label="Permalink to &quot;基本的编解码器&quot;">​</a></h2><p><code>Python</code>自带了超过 100 种编解码器<code>（codec, encoder/decoder）</code>，用于在文本和字节之间相互转换。每个编解码器都有一个名称，如&#39;utf_8&#39;，而且经常有几个别名，如&#39;utf8&#39;、&#39;utf-8&#39;和&#39;U8&#39;。这些名称可以传给<code>open（　）、</code>str.encode（　）<code>、</code>bytes.decode（　）\`等函数的 encoding 参数。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> codec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;latin_1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf_8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf_16&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(codec, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;El Niño&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.encode(codec), </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><pre><code>latin_1	b&#39;El Ni\\xf1o&#39;
utf_8	b&#39;El Ni\\xc3\\xb1o&#39;
utf_16	b&#39;\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00&#39;
</code></pre><p>处理编码问题：略（遇到了再说）</p><p>有些通信协议和文件格式，如 HTTP 和 XML，包含明确指明内容编码的首部。可以肯定的是，某些字节流不是 ASCII，因为其中包含大于 127 的字节值，而且制定 UTF-8 和 UTF-16 的方式也限制了可用的字节序列。不过即便如此，我们也不能根据特定的位模式来 100%确定二进制文件的编码是 ASCII 或 UTF-8。</p><p>然而，就像人类语言也有规则和限制一样，只要假定字节流是人类可读的纯文本，就可能通过试探和分析找出编码。例如，如果<code>b&#39;\\x00&#39;</code>字节经常出现，那么可能是 16 位或 32 位编码，而不是 8 位编码方案，因为纯文本中不能包含空字符；如果字节序列<code>b&#39;\\x20\\x00&#39;</code>经常出现，那么可能是 UTF-16LE 编码中的空格字符（U+0020），而不是鲜为人知的 U+2000 EN QUAD 字符</p><p>统一字符编码侦测包 Chardet 就是这样工作的，它能识别所支持的 30 种编码。</p><h2 id="处理文本文件" tabindex="-1">处理文本文件 <a class="header-anchor" href="#处理文本文件" aria-label="Permalink to &quot;处理文本文件&quot;">​</a></h2><p>处理文本的最佳实践是“Unicode 三明治”</p><p><img src="https://oss.justin3go.com/blogs/20240202162239.png" alt=""></p><p>需要在多台设备中或多种场合下运行的代码，一定不能依赖默认编码。打开文件时始终应该明确传入 encoding=参数，因为不同的设备使用的默认编码可能不同，有时隔一天也会发生变化。</p><h2 id="为了正确比较而规范化-unicode-字符串" tabindex="-1">为了正确比较而规范化 Unicode 字符串 <a class="header-anchor" href="#为了正确比较而规范化-unicode-字符串" aria-label="Permalink to &quot;为了正确比较而规范化 Unicode 字符串&quot;">​</a></h2><p>因为 Unicode 有组合字符（变音符号和附加到前一个字符上的记号，打印时作为一个整体），所以字符串比较起来很复杂。</p><p>“café”这个词可以使用两种方式构成，分别有 4 个和 5 个码位，但是结果完全一样</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;café&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cafe</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\u0301</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1, s2</span></span></code></pre></div><pre><code>(&#39;café&#39;, &#39;café&#39;)
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s2)</span></span></code></pre></div><pre><code>(4, 5)
</code></pre><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2</span></span></code></pre></div><pre><code>False
</code></pre><p><code>U+0301</code>是 COMBINING ACUTE ACCENT，加在“e”后面得到“é”。在 Unicode 标准中，&#39;é&#39;和<code>&#39;e\\u0301&#39;</code>这样的序列叫“标准等价物”（canonical equivalent），应用程序应该把它们视作相同的字符。但是，Python 看到的是不同的码位序列，因此判定二者不相等。</p><p>这个问题的解决方案是使用<code>unicodedata.normalize</code>函数提供的 Unicode 规范化。这个函数的第一个参数是这 4 个字符串中的一个：&#39;NFC&#39;、&#39;NFD&#39;、&#39;NFKC&#39;和&#39;NFKD&#39;。下面先说明前两个。</p><ul><li>NFC（Normalization Form C）使用最少的码位构成等价的字符串，</li><li>而 NFD 把组合字符分解成基字符和单独的组合字符。</li></ul><p>使用 NFKC 和 NFKD 规范化形式时要小心，而且只能在特殊情况中使用，例如搜索和索引，而不能用于持久存储，因为这两种转换会导致数据损失。</p><p>大小写折叠其实就是把所有文本变成小写，再做些其他转换。这个功能由<code>str.casefold（　）</code>方法（Python 3.3 新增）支持。对于只包含 latin1 字符的字符串 s，<code>s.casefold（　）</code>得到的结果与<code>s.lower（　）</code>一样，唯有两个例外：微符号&#39;µ&#39;会变成小写的希腊字母“μ”（在多数字体中二者看起来一样）；德语<code>Eszett（“sharp s”，ß）</code>会变成“ss”。</p><p>略一些</p><h2 id="支持字符串和字节序列的双模式-api" tabindex="-1">支持字符串和字节序列的双模式 API <a class="header-anchor" href="#支持字符串和字节序列的双模式-api" aria-label="Permalink to &quot;支持字符串和字节序列的双模式 API&quot;">​</a></h2><p>标准库中的一些函数能接受字符串或字节序列为参数，然后根据类型展现不同的行为。re 和 os 模块中就有这样的函数。</p><p>如果使用字节序列构建正则表达式，<code>\\d</code>和<code>\\w</code>等模式只能匹配 ASCII 字符；相比之下，如果是字符串模式，就能匹配 ASCII 之外的 Unicode 数字或字母。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">re_numbers_str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re.compile(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字符串类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">re_words_str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re.compile(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字符串类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">re_numbers_bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re.compile(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字节序列类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">re_words_bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re.compile(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字节序列类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text_str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ramanujan saw </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\u0be7\\u0bed\\u0be8\\u0bef</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot; as 1729 = 1³+12³ = 9³+10³.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text_bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text_str.encode(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf_8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Text&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">repr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text_str), </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Numbers&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;  str  :&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, re_numbers_str.findall(text_str))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;  bytes:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, re_numbers_bytes.findall(text_bytes))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Words&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;  str  :&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, re_words_str.findall(text_str))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;  bytes:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, re_words_bytes.findall(text_bytes))</span></span></code></pre></div><pre><code>Text
  &#39;Ramanujan saw ௧௭௨௯ as 1729 = 1³+12³ = 9³+10³.&#39;
Numbers
  str  : [&#39;௧௭௨௯&#39;, &#39;1729&#39;, &#39;1&#39;, &#39;12&#39;, &#39;9&#39;, &#39;10&#39;]
  bytes: [b&#39;1729&#39;, b&#39;1&#39;, b&#39;12&#39;, b&#39;9&#39;, b&#39;10&#39;]
Words
  str  : [&#39;Ramanujan&#39;, &#39;saw&#39;, &#39;௧௭௨௯&#39;, &#39;as&#39;, &#39;1729&#39;, &#39;1³&#39;, &#39;12³&#39;, &#39;9³&#39;, &#39;10³&#39;]
  bytes: [b&#39;Ramanujan&#39;, b&#39;saw&#39;, b&#39;as&#39;, b&#39;1729&#39;, b&#39;1&#39;, b&#39;12&#39;, b&#39;9&#39;, b&#39;10&#39;]
</code></pre><p>GNU/Linux 内核不理解 Unicode，因此你可能发现了，对任何合理的编码方案来说，在文件名中使用字节序列都是无效的，无法解码成字符串。在不同操作系统中使用各种客户端的文件服务器，在遇到这个问题时尤其容易出错。</p><p>为了规避这个问题，os 模块中的所有函数、文件名或路径名参数既能使用字符串，也能使用字节序列。如果这样的函数使用字符串参数调用，该参数会使用 sys.getfilesystemencoding（　）得到的编解码器自动编码，然后操作系统会使用相同的编解码器解码。这几乎就是我们想要的行为，与 Unicode 三明治最佳实践一致。</p><p>但是，如果必须处理（也可能是修正）那些无法使用上述方式自动处理的文件名，可以把字节序列参数传给 os 模块中的函数，得到字节序列返回值。这一特性允许我们处理任何文件名或路径名，不管里面有多少鬼符</p>`,77),h=[e];function p(l,k,d,r,o,c){return a(),i("div",null,h)}const g=s(t,[["render",p]]);export{y as __pageData,g as default};
