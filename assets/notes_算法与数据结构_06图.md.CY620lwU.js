import{_ as s,D as i,B as a,ah as n}from"./chunks/framework.kYnPRA0Y.js";const o=JSON.parse('{"title":"图","description":"","frontmatter":{},"headers":[],"relativePath":"notes/算法与数据结构/06图.md","filePath":"notes/算法与数据结构/06图.md","lastUpdated":1738344267000}'),l={name:"notes/算法与数据结构/06图.md"},p=n(`<h1 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-label="Permalink to &quot;图&quot;">​</a></h1><h2 id="图的关键词" tabindex="-1">图的关键词 <a class="header-anchor" href="#图的关键词" aria-label="Permalink to &quot;图的关键词&quot;">​</a></h2><ul><li>完全图 <ul><li>无向图需要有 n(n-1)/2 条边。</li><li>有向图需要有 n(n-1)条弧。</li></ul></li><li>邻接点</li><li>度（有向图还有出度和入度）</li><li>子图</li><li>路径</li><li>路径长度</li><li>简单路径：顶点不重复出现的路径。</li><li>回路：第一个顶点和最后一个顶点相同的路径。</li><li>简单回路：除第一顶点和最后以顶点外，其余顶点不重复出现的回路。</li><li>权：在图的每条边上加数字作权。</li><li>网：带权的图称为网。</li></ul><hr><ul><li><p>连通：无向图中，如果从顶点 v 到顶点 v~有路径，则称 v 和 v~是连通的。</p></li><li><p><strong>连通图</strong>：如果图中任意两个顶点都是连通的，则是连通图。</p></li><li><p><strong>连通分量</strong>相关：</p><ul><li>也叫无向图的<strong>极大连通子图</strong></li><li>连通图只有一个连通分量，即其自身</li><li>非连通的无向图有多个连通分量</li></ul></li><li><p><strong>强连通图</strong>：有向图中每一对顶点都存在路径，则称 G 是强连通图。</p></li><li><p><strong>强连通分量</strong>：</p><ul><li>有向图的极大连通子图称作强连通分量。</li><li>强连通图的强连通分量是其自身</li><li>非强连通的有向图可能有多个强连通分量</li></ul></li><li><p>生成树</p><ul><li>一个连通图的<strong>极小连通子图</strong></li><li>含有图中全部 n 个顶点，但只有能令图连通的 n-1 条边</li></ul><img src="https://oss.justin3go.com/blogs/image-20210609191424667.png" alt="image-20210609191424667" style="zoom:50%;"></li></ul><h2 id="图的存储" tabindex="-1">图的存储 <a class="header-anchor" href="#图的存储" aria-label="Permalink to &quot;图的存储&quot;">​</a></h2><h3 id="邻接矩阵" tabindex="-1">邻接矩阵 <a class="header-anchor" href="#邻接矩阵" aria-label="Permalink to &quot;邻接矩阵&quot;">​</a></h3><p>创建<strong>顶点集</strong>和创建<strong>关系集</strong></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//图的邻接矩阵存储</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NMAX</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> datatype;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    datatype vexes[NMAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> edge[NMAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][NMAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n,e</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ga;</span></span></code></pre></div><p>算法思路：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>step1:创建 ga 的存储空间</span></span>
<span class="line"><span>step2:输入边数 ga-&gt;e</span></span>
<span class="line"><span>step3:输入顶点数 ga-&gt;n</span></span>
<span class="line"><span>step4:初始化顶点集 ga-&gt;vexes</span></span>
<span class="line"><span>	foreach k in (1~ga-&gt;n)</span></span>
<span class="line"><span>		输入顶点的数据 data</span></span>
<span class="line"><span>		ga-&gt;vexes[k]=data</span></span>
<span class="line"><span>step5:初始化邻接矩阵 ga-&gt;edges 为全 0</span></span>
<span class="line"><span>step6:创建边集</span></span>
<span class="line"><span>	foreach k in (1~ga-&gt;e)</span></span>
<span class="line"><span>		输入边的顶点偶对：（i,j）</span></span>
<span class="line"><span>		ga-&gt;edges[i][j]=1</span></span>
<span class="line"><span>		ga-&gt;edges[j][i]=1</span></span>
<span class="line"><span>step7:return ga</span></span></code></pre></div><img src="https://oss.justin3go.com/blogs/image-20210609194316082.png" alt="image-20210609194316082" style="zoom:50%;"><h3 id="邻接表" tabindex="-1">邻接表 <a class="header-anchor" href="#邻接表" aria-label="Permalink to &quot;邻接表&quot;">​</a></h3><p>顶点表</p><p><strong>边表：边表结点保存着与某顶点关联的另一顶点和指向下一表结点的指针</strong></p><img src="https://oss.justin3go.com/blogs/image-20210609194419001.png" alt="image-20210609194419001" style="zoom:50%;"><p><strong>邻接表结构</strong>定义：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NMAX</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //顶点的最大数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //边表结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vertex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edgenode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //顶点表结点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vextype data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    edgenode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //边表头指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vexnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //图的定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vexnode vexes[NMAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //顶点表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n, e;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //顶点数、边数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ga;</span></span></code></pre></div><p>算法思路：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#初始化顶点表 ga-&gt;vexes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ga</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 输入数据 data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ga</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vexes[k].data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ga</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vexes[k].head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#创建边表集</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ga</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 输入边的顶点对（i，j）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 将顶点 j 添加到顶点 i 的边表中</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    	# 生成边表结点 p</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 结点数据域赋值：p-&gt;vertex=j</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 在边表中加入结点 p</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        	# p-&gt;next=ga-&gt;vertex[i].head</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # ga-&gt;vertex[i].head=p</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 将顶点 i 添加到顶点 j 的边表中</span></span></code></pre></div><h3 id="十字链表" tabindex="-1">十字链表 <a class="header-anchor" href="#十字链表" aria-label="Permalink to &quot;十字链表&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//边表结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arctype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tailvex, headvex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arctype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hlink,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tlink;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arclink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//顶点表结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vertex data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arclink </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstin, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstout;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ortholistNode</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ortholistNode</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NMAX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><img src="https://oss.justin3go.com/blogs/image-20220120202043847.png" alt="image-20220120202043847" style="zoom:67%;"><h3 id="边集数组" tabindex="-1">边集数组 <a class="header-anchor" href="#边集数组" aria-label="Permalink to &quot;边集数组&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fromvex;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//边的起点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endvex;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//边的终点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weight;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//边的权值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EDGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EDGE edgeet[MaxEDGEnUM];</span></span></code></pre></div><img src="https://oss.justin3go.com/blogs/image-20220120202023107.png" alt="image-20220120202023107" style="zoom:80%;"><h2 id="图的遍历" tabindex="-1">图的遍历 <a class="header-anchor" href="#图的遍历" aria-label="Permalink to &quot;图的遍历&quot;">​</a></h2><p>要求：<strong>无重复、无遗漏</strong>。</p><p>关键点：</p><ul><li>图中可能<strong>存在回路</strong>。</li><li>顶点可能与其它顶点相通，访问完某顶点后，可能沿着某些边回到曾经访问过的顶点。</li><li>为<strong>避免重复访问</strong>，可设辅助数组 visited[] <ul><li>将其初始化为 0.</li><li>遍历时，如果某顶点 i 被访问，将 visited[i]置为 1。</li><li>以此防止顶点 i 被多次访问。</li></ul></li></ul><p><strong>深度优先</strong>(递归解法)：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//邻接矩阵：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visied[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga, vi){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vi);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //访问结点 vi</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visited[vi]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga-&gt;edges[vi][k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">visited[k])</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            DFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga, k);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//邻接表：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visied[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga, vi){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vi);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visited[vi] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga-&gt;vexes[vi]).head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">visited[p-&gt;vertex])</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            DFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ga, p-&gt;vertex);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p-&gt;next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>深度优先（栈）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>step1:设初始状态：图中所有顶点都没被访问过</span></span>
<span class="line"><span>foreach i in (1~n)</span></span>
<span class="line"><span>	visited[i] = 0;</span></span>
<span class="line"><span>step2:初始化栈 stack</span></span>
<span class="line"><span>step3:c=r,push(stack,c) //r 为出发顶点的编号</span></span>
<span class="line"><span>step4:访问顶点 vc,令 visited[c]=1</span></span>
<span class="line"><span>step5:找到并访问与顶点 vc 邻接，但未被访问过的顶点 v_j</span></span>
<span class="line"><span>for(j:1~n)</span></span>
<span class="line"><span>	if(ga[c][j] == 1 and visited[j] == 0)</span></span>
<span class="line"><span>		c = j, push(stack, j)转 step4</span></span>
<span class="line"><span>step6:当 vc 所有的邻接点均被访问过，则退回到最近被访问的前一顶点。</span></span>
<span class="line"><span>	if(!emptystack(stack))</span></span>
<span class="line"><span>		c=pop(stack),转 step5</span></span>
<span class="line"><span>    else return;</span></span></code></pre></div><p><strong>广度优先</strong>：类似于<strong>树的层次遍历</strong>，使用<strong>队列</strong>辅助存储。</p><p><strong>图的连通性</strong>：如果遍历完成时 DFS 或 BFS 仅调用一次，则图是连通图；若被调用多次，则图是非连通图，分别访问多个连通分量。</p><h2 id="图的拓扑排序" tabindex="-1">图的拓扑排序 <a class="header-anchor" href="#图的拓扑排序" aria-label="Permalink to &quot;图的拓扑排序&quot;">​</a></h2><img src="https://oss.justin3go.com/blogs/image-20210609210740434.png" alt="image-20210609210740434" style="zoom:50%;"><p><img src="https://oss.justin3go.com/blogs/image-20220120202006590.png" alt="image-20220120202006590"></p><p>AOV：</p><ul><li>顶点表示活动，弧表示活动间的先后关系。</li><li>AOV 网中不能有回路，回路意味着某项活动以自己为先决条件。</li><li>死锁。</li></ul><p>拓扑排序：</p><ul><li>把 AOV 网中各顶点按其活动的先后关系，排列成一个线性序列的过程。</li><li>拓扑序列</li><li>AOV 网用邻接表存储</li><li>在邻接表的表头结点增加存放顶点入度的域。</li><li><strong>栈或队列存放入度为零的顶点</strong>。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>拓扑排序：对有 n 个顶点的有向图 ga，以邻接表方式存储，找出一条拓扑序列。</span></span>
<span class="line"><span>step1:初始化栈 stack，令 count=0</span></span>
<span class="line"><span>step2:创建 ga 的邻接表，初始化每个顶点的入度为 0</span></span>
<span class="line"><span>step3:将当前可开始的活动入栈</span></span>
<span class="line"><span>	foreach k in 1~n</span></span>
<span class="line"><span>		if(ga-&gt;vexes[k].indegree==0)</span></span>
<span class="line"><span>			push(stack, k)</span></span>
<span class="line"><span>step4:while(!empty(stack))</span></span>
<span class="line"><span>	vi = pop(stack)</span></span>
<span class="line"><span>	visit(vi),count++</span></span>
<span class="line"><span>	将后续活动的入度减 1，并记录新的可开始的活动。</span></span>
<span class="line"><span>		p=ga-&gt;vexes[vi].head</span></span>
<span class="line"><span>		while(p)</span></span>
<span class="line"><span>			ga-&gt;vexes[p-&gt;data].indegree--</span></span>
<span class="line"><span>			if(ga-&gt;vexes[p-&gt;data].indegree==0)</span></span>
<span class="line"><span>				push(stack,p-&gt;data)</span></span>
<span class="line"><span>            p = p-&gt;next;</span></span>
<span class="line"><span>step3:如仍有活动未进行，return FALSE,否则 return TRUE</span></span>
<span class="line"><span>	if(count&lt;n)</span></span>
<span class="line"><span>		return FALSE;</span></span></code></pre></div><h2 id="图的最小生成树" tabindex="-1">图的最小生成树 <a class="header-anchor" href="#图的最小生成树" aria-label="Permalink to &quot;图的最小生成树&quot;">​</a></h2><h3 id="生成树" tabindex="-1">生成树 <a class="header-anchor" href="#生成树" aria-label="Permalink to &quot;生成树&quot;">​</a></h3><ul><li>连通图 G 的极小连通子图，称为图的生成树</li><li>包含图中所有顶点</li><li>无回路 <ul><li><strong>n 个顶点，只有 n-1 条边。</strong></li><li>任意去掉一条边，图将变为非连通图</li><li>添加一条边，图中将出现回路</li></ul></li><li><strong>含 n 个顶点 n-1 的图不一定是最小生成树</strong></li><li>深度优先生成树</li><li>广度优先生成树</li><li>图的生成树不是唯一的</li><li>从不同的顶点出发，可得到不同的生成树。</li></ul><h3 id="图的最小生成树-1" tabindex="-1">图的最小生成树 <a class="header-anchor" href="#图的最小生成树-1" aria-label="Permalink to &quot;图的最小生成树&quot;">​</a></h3><ul><li>连通网络 G=（V，E）的各边带权</li><li>因此其生成树各边带权</li><li>生成树的权 <ul><li>生成树各边权值的和</li></ul></li><li><strong>最小生成树（MST）</strong><ul><li>权值最小的生成树</li></ul></li></ul><h3 id="prim-算法" tabindex="-1">PRIM 算法 <a class="header-anchor" href="#prim-算法" aria-label="Permalink to &quot;PRIM 算法&quot;">​</a></h3><p>初始 U 中含任意一个顶点 u0，初始候选边集 <img src="https://oss.justin3go.com/blogs/image-20210609213706268.png" alt="image-20210609213706268" style="zoom:50%;"></p><ul><li>numv=1</li><li>while(numv=1){</li><li>​ 从 C 中选最短边并入边集 E，点集 U</li><li>​ numv++</li><li>​ 调整候选边集 C <img src="https://oss.justin3go.com/blogs/image-20210609214143152.png" alt="image-20210609214143152" style="zoom:50%;"></li><li></li></ul><img src="https://oss.justin3go.com/blogs/image-20210609214218953.png" alt="image-20210609214218953" style="zoom:50%;"><h3 id="kruskal-算法" tabindex="-1">Kruskal 算法 <a class="header-anchor" href="#kruskal-算法" aria-label="Permalink to &quot;Kruskal 算法&quot;">​</a></h3><p>算法思想：权值由小到大开始来连接，连通的不要，直到生成生成树，即最小生成树。</p><img src="https://oss.justin3go.com/blogs/image-20210609214529186.png" alt="image-20210609214529186" style="zoom:50%;"><img src="https://oss.justin3go.com/blogs/image-20210609214547290.png" alt="image-20210609214547290" style="zoom:50%;">`,58),t=[p];function h(e,k,g,r,d,E){return a(),i("div",null,t)}const y=s(l,[["render",h]]);export{o as __pageData,y as default};
