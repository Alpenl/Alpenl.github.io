import{_ as i,D as s,B as a,ah as e}from"./chunks/framework.kYnPRA0Y.js";const c=JSON.parse('{"title":"Vue3 是如何运行的","description":"","frontmatter":{},"headers":[],"relativePath":"notes/Vue相关/01Vue3是如何运行的.md","filePath":"notes/Vue相关/01Vue3是如何运行的.md","lastUpdated":1738327344000}'),t={name:"notes/Vue相关/01Vue3是如何运行的.md"},l=e(`<h1 id="vue3-是如何运行的" tabindex="-1">Vue3 是如何运行的 <a class="header-anchor" href="#vue3-是如何运行的" aria-label="Permalink to &quot;Vue3 是如何运行的&quot;">​</a></h1><h2 id="dom-操作介绍" tabindex="-1">Dom 操作介绍 <a class="header-anchor" href="#dom-操作介绍" aria-label="Permalink to &quot;Dom 操作介绍&quot;">​</a></h2><p><img src="https://oss.justin3go.com/blogs/image-20220129100001122.png" alt="image-20220129100001122"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;h1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进行更新操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.textContent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;New Heading&quot;</span></span></code></pre></div><h2 id="virtual-dom" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom" aria-label="Permalink to &quot;Virtual DOM&quot;">​</a></h2><p>搜索和更新数千个 DOM 节点很明显会变慢，这就是 Vue 和其他类似框架的作用----Virtual DOM</p><p><img src="https://oss.justin3go.com/blogs/image-20220129100552930.png" alt="image-20220129100552930"></p><p>Virual Node 是一个 JavaScript 对象，Vue 知道如何使用这些 Virtual Node 并挂载待 DOM 上，它会更新我们在浏览器上看到的内容，每个 VNode 对应一个 DOM 节点，Vue 通过寻找更新 VNode 最小的更新数量，然后再将最优策略施加到实际 DOM 中，从而减少 DOM 操作，提高性能</p><p>还有一步&lt;一个渲染函数&gt;：</p><p><img src="https://oss.justin3go.com/blogs/image-20220129101003422.png" alt="image-20220129101003422"></p><p>当组件改变时，Render 函数将重新运行，它将创建另一个虚拟节点，然后发送旧的 VNode 和新的 VNode 到 Vue 中进行比较，并以最高效的方式在我们的网页上更新；</p><p><img src="https://oss.justin3go.com/blogs/image-20220129101347615.png" alt="image-20220129101347615"></p><p>可以将 Virtual DOM 与 actual DOM 类比为蓝图与实际建筑的关系：</p><ul><li>当我更改 29 楼的一些数据&lt;家具的布局&gt;</li><li>我可以拆除 29 楼的一切，重头开始；</li><li>我还可以创建新的蓝图对比旧的蓝图，并进行更新以尽可能减少工作量</li></ul><h2 id="vue3-三个核心模块" tabindex="-1">Vue3 三个核心模块 <a class="header-anchor" href="#vue3-三个核心模块" aria-label="Permalink to &quot;Vue3 三个核心模块&quot;">​</a></h2><ul><li>Reactive Module <ul><li>跟踪、观察变化并作出相应的改变</li></ul></li><li>Compiler Module <ul><li>获取 HTML 模板并将它们编译成渲染函数</li><li>浏览器可以只接收渲染函数</li></ul></li><li>Render Module <ul><li>Render Phase</li><li>Mount Phase</li><li>Patch Phase</li></ul></li></ul><p><img src="https://oss.justin3go.com/blogs/image-20220129111119209.png" alt="image-20220129111119209"></p><h2 id="一个简单组件的执行" tabindex="-1">一个简单组件的执行 <a class="header-anchor" href="#一个简单组件的执行" aria-label="Permalink to &quot;一个简单组件的执行&quot;">​</a></h2><ul><li><p>首先编译模块将 HTML 转换为一个渲染函数</p></li><li><img src="https://oss.justin3go.com/blogs/image-20220129111603732.png" alt="image-20220129111603732" style="zoom:67%;"></li><li><p>然后初始化响应式对象使用响应式模块：</p></li><li><img src="https://oss.justin3go.com/blogs/image-20220129111735770.png" alt="image-20220129111735770" style="zoom:67%;"></li><li><p>渲染模块中，我们进入渲染阶段，调用 render 函数，它引用了响应对象，我们现在观察这个响应对象的变化，render 函数返回一个虚拟 DOM 节点</p></li><li><img src="https://oss.justin3go.com/blogs/image-20220129111954115.png" alt="image-20220129111954115" style="zoom:67%;"></li><li><p>挂载阶段调用 mount 函数，使用虚拟 DOM 节点创建 web 界面</p></li><li><img src="https://oss.justin3go.com/blogs/image-20220129112042885.png" alt="image-20220129112042885" style="zoom:67%;"></li><li><p>最后，如果我们的响应对象发生任何变化，渲染器再次调用 render 函数，创建一个新的虚拟 DOM 节点，新旧发送补丁函数中，按需更新我们的网页</p></li><li><img src="https://oss.justin3go.com/blogs/image-20220129112301023.png" alt="image-20220129112301023" style="zoom:67%;"></li></ul>`,19),o=[l];function n(p,h,r,g,u,d){return a(),s("div",null,o)}const k=i(t,[["render",n]]);export{c as __pageData,k as default};
